{
  "version": 3,
  "sources": ["../../node_modules/micro-packed/src/index.ts", "../../node_modules/@scure/btc-signer/src/utils.ts", "../../node_modules/@scure/btc-signer/src/script.ts", "../../node_modules/@scure/btc-signer/src/psbt.ts", "../../node_modules/@scure/btc-signer/src/payment.ts", "../../node_modules/@scure/btc-signer/src/transaction.ts", "../../node_modules/@scure/btc-signer/src/utxo.ts", "../../node_modules/@scure/btc-signer/src/index.ts"],
  "sourcesContent": ["import { hex as baseHex, utf8, type Coder as BaseCoder } from '@scure/base';\n\n/**\n * Define complex binary structures using composable primitives.\n * Main ideas:\n * - Encode / decode can be chained, same as in `scure-base`\n * - A complex structure can be created from an array and struct of primitive types\n * - Strings / bytes are arrays with specific optimizations: we can just read bytes directly\n *   without creating plain array first and reading each byte separately.\n * - Types are inferred from definition\n * @module\n * @example\n * import * as P from 'micro-packed';\n * const s = P.struct({\n *   field1: P.U32BE, // 32-bit unsigned big-endian integer\n *   field2: P.string(P.U8), // String with U8 length prefix\n *   field3: P.bytes(32), // 32 bytes\n *   field4: P.array(P.U16BE, P.struct({ // Array of structs with U16BE length\n *     subField1: P.U64BE, // 64-bit unsigned big-endian integer\n *     subField2: P.string(10) // 10-byte string\n *   }))\n * });\n */\n\n// TODO: remove dependency on scure-base & inline?\n\n/*\nExports can be groupped like this:\n\n- Primitive types: P.bytes, P.string, P.hex, P.constant, P.pointer\n- Complex types: P.array, P.struct, P.tuple, P.map, P.tag, P.mappedTag\n- Padding, prefix, magic: P.padLeft, P.padRight, P.prefix, P.magic, P.magicBytes\n- Flags: P.flag, P.flagged, P.optional\n- Wrappers: P.apply, P.wrap, P.lazy\n- Bit fiddling: P.bits, P.bitset\n- utils: P.validate, coders.decimal\n- Debugger\n*/\n\n/** Shortcut to zero-length (empty) byte array */\nexport const EMPTY: Uint8Array = /* @__PURE__ */ new Uint8Array();\n/** Shortcut to one-element (element is 0) byte array */\nexport const NULL: Uint8Array = /* @__PURE__ */ new Uint8Array([0]);\n\n/** Checks if two Uint8Arrays are equal. Not constant-time. */\nfunction equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n/** Checks if the given value is a Uint8Array. */\nfunction isBytes(a: unknown): a is Bytes {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/**\n * Concatenates multiple Uint8Arrays.\n * Engines limit functions to 65K+ arguments.\n * @param arrays Array of Uint8Array elements\n * @returns Concatenated Uint8Array\n */\nfunction concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n/**\n * Creates DataView from Uint8Array\n * @param arr - bytes\n * @returns DataView\n */\nconst createView = (arr: Uint8Array) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n/**\n * Checks if the provided value is a plain object, not created from any class or special constructor.\n * Array, Uint8Array and others are not plain objects.\n * @param obj - The value to be checked.\n */\nfunction isPlainObject(obj: any): boolean {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isNum(num: unknown): num is number {\n  return Number.isSafeInteger(num);\n}\n\nexport const utils: {\n  equalBytes: typeof equalBytes;\n  isBytes: typeof isBytes;\n  isCoder: typeof isCoder;\n  checkBounds: typeof checkBounds;\n  concatBytes: typeof concatBytes;\n  createView: (arr: Uint8Array) => DataView;\n  isPlainObject: typeof isPlainObject;\n} = {\n  equalBytes,\n  isBytes,\n  isCoder,\n  checkBounds,\n  concatBytes,\n  createView,\n  isPlainObject,\n};\n\n// Types\nexport type Bytes = Uint8Array;\nexport type Option<T> = T | undefined;\n/**\n * Coder encodes and decodes between two types.\n * @property {(from: F) => T} encode - Encodes (converts) F to T\n * @property {(to: T) => F} decode - Decodes (converts) T to F\n */\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n/**\n * BytesCoder converts value between a type and a byte array\n * @property {number} [size] - Size hint for the element.\n * @property {(data: T) => Bytes} encode - Encodes a value of type T to a byte array\n * @property {(data: Bytes, opts?: ReaderOpts) => T} decode - Decodes a byte array to a value of type T\n */\nexport interface BytesCoder<T> extends Coder<T, Bytes> {\n  size?: number; // Size hint element\n  encode: (data: T) => Bytes;\n  decode: (data: Bytes, opts?: ReaderOpts) => T;\n}\n/**\n * BytesCoderStream converts value between a type and a byte array, using streams.\n * @property {number} [size] - Size hint for the element.\n * @property {(w: Writer, value: T) => void} encodeStream - Encodes a value of type T to a byte array using a Writer stream.\n * @property {(r: Reader) => T} decodeStream - Decodes a byte array to a value of type T using a Reader stream.\n */\nexport interface BytesCoderStream<T> {\n  size?: number;\n  encodeStream: (w: Writer, value: T) => void;\n  decodeStream: (r: Reader) => T;\n}\nexport type CoderType<T> = BytesCoderStream<T> & BytesCoder<T>;\nexport type Sized<T> = CoderType<T> & { size: number };\nexport type UnwrapCoder<T> = T extends CoderType<infer U> ? U : T;\n/**\n * Validation function. Should return value after validation.\n * Can be used to narrow types\n */\nexport type Validate<T> = (elm: T) => T;\n\nexport type Length = CoderType<number> | CoderType<bigint> | number | Bytes | string | null;\n\n// NOTE: we can't have terminator separate function, since it won't know about boundaries\n// E.g. array of U16LE ([1,2,3]) would be [1, 0, 2, 0, 3, 0]\n// But terminator will find array at index '1', which happens to be inside of an element itself\n/**\n * Can be:\n * - Dynamic (CoderType)\n * - Fixed (number)\n * - Terminated (usually zero): Uint8Array with terminator\n * - Field path to field with length (string)\n * - Infinity (null) - decodes until end of buffer\n * Used in:\n * - bytes (string, prefix is implementation of bytes)\n * - array\n */\nconst lengthCoder = (len: Length) => {\n  if (len !== null && typeof len !== 'string' && !isCoder(len) && !isBytes(len) && !isNum(len)) {\n    throw new Error(\n      `lengthCoder: expected null | number | Uint8Array | CoderType, got ${len} (${typeof len})`\n    );\n  }\n  return {\n    encodeStream(w: Writer, value: number | null) {\n      if (len === null) return;\n      if (isCoder(len)) return len.encodeStream(w, value);\n      let byteLen;\n      if (typeof len === 'number') byteLen = len;\n      else if (typeof len === 'string') byteLen = Path.resolve((w as _Writer).stack, len);\n      if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n      if (byteLen === undefined || byteLen !== value)\n        throw w.err(`Wrong length: ${byteLen} len=${len} exp=${value} (${typeof value})`);\n    },\n    decodeStream(r: Reader) {\n      let byteLen;\n      if (isCoder(len)) byteLen = Number(len.decodeStream(r));\n      else if (typeof len === 'number') byteLen = len;\n      else if (typeof len === 'string') byteLen = Path.resolve((r as _Reader).stack, len);\n      if (typeof byteLen === 'bigint') byteLen = Number(byteLen);\n      if (typeof byteLen !== 'number') throw r.err(`Wrong length: ${byteLen}`);\n      return byteLen;\n    },\n  };\n};\n\ntype ArrLike<T> = Array<T> | ReadonlyArray<T>;\n// prettier-ignore\nexport type TypedArray =\n  | Uint8Array  | Int8Array | Uint8ClampedArray\n  | Uint16Array | Int16Array\n  | Uint32Array | Int32Array;\n\n/** Writable version of a type, where readonly properties are made writable. */\nexport type Writable<T> = T extends {}\n  ? T extends TypedArray\n    ? T\n    : {\n        -readonly [P in keyof T]: Writable<T[P]>;\n      }\n  : T;\nexport type Values<T> = T[keyof T];\nexport type NonUndefinedKey<T, K extends keyof T> = T[K] extends undefined ? never : K;\nexport type NullableKey<T, K extends keyof T> = T[K] extends NonNullable<T[K]> ? never : K;\n// Opt: value !== undefined, but value === T|undefined\nexport type OptKey<T, K extends keyof T> = NullableKey<T, K> & NonUndefinedKey<T, K>;\nexport type ReqKey<T, K extends keyof T> = T[K] extends NonNullable<T[K]> ? K : never;\n\nexport type OptKeys<T> = Pick<T, { [K in keyof T]: OptKey<T, K> }[keyof T]>;\nexport type ReqKeys<T> = Pick<T, { [K in keyof T]: ReqKey<T, K> }[keyof T]>;\nexport type StructInput<T extends Record<string, any>> = { [P in keyof ReqKeys<T>]: T[P] } & {\n  [P in keyof OptKeys<T>]?: T[P];\n};\nexport type StructRecord<T extends Record<string, any>> = {\n  [P in keyof T]: CoderType<T[P]>;\n};\n\nexport type StructOut = Record<string, any>;\n/** Padding function that takes an index and returns a padding value. */\nexport type PadFn = (i: number) => number;\n\n/**\n * Small bitset structure to store position of ranges that have been read.\n * Can be more efficient when internal trees are utilized at the cost of complexity.\n * Needs `O(N/8)` memory for parsing.\n * Purpose: if there are pointers in parsed structure,\n * they can cause read of two distinct ranges:\n * [0-32, 64-128], which means 'pos' is not enough to handle them\n */\nconst Bitset = {\n  BITS: 32,\n  FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n  len: (len: number) => Math.ceil(len / 32),\n  create: (len: number) => new Uint32Array(Bitset.len(len)),\n  clean: (bs: Uint32Array) => bs.fill(0),\n  debug: (bs: Uint32Array) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n  checkLen: (bs: Uint32Array, len: number) => {\n    if (Bitset.len(len) === bs.length) return;\n    throw new Error(`wrong length=${bs.length}. Expected: ${Bitset.len(len)}`);\n  },\n  chunkLen: (bsLen: number, pos: number, len: number) => {\n    if (pos < 0) throw new Error(`wrong pos=${pos}`);\n    if (pos + len > bsLen) throw new Error(`wrong range=${pos}/${len} of ${bsLen}`);\n  },\n  set: (bs: Uint32Array, chunk: number, value: number, allowRewrite = true) => {\n    if (!allowRewrite && (bs[chunk] & value) !== 0) return false;\n    bs[chunk] |= value;\n    return true;\n  },\n  pos: (pos: number, i: number) => ({\n    chunk: Math.floor((pos + i) / 32),\n    mask: 1 << (32 - ((pos + i) % 32) - 1),\n  }),\n  indices: (bs: Uint32Array, len: number, invert = false) => {\n    Bitset.checkLen(bs, len);\n    const { FULL_MASK, BITS } = Bitset;\n    const left = BITS - (len % BITS);\n    const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n    const res = [];\n    for (let i = 0; i < bs.length; i++) {\n      let c = bs[i];\n      if (invert) c = ~c; // allows to gen unset elements\n      // apply mask to last element, so we won't iterate non-existent items\n      if (i === bs.length - 1) c &= lastMask;\n      if (c === 0) continue; // fast-path\n      for (let j = 0; j < BITS; j++) {\n        const m = 1 << (BITS - j - 1);\n        if (c & m) res.push(i * BITS + j);\n      }\n    }\n    return res;\n  },\n  range: (arr: number[]) => {\n    const res = [];\n    let cur;\n    for (const i of arr) {\n      if (cur === undefined || i !== cur.pos + cur.length) res.push((cur = { pos: i, length: 1 }));\n      else cur.length += 1;\n    }\n    return res;\n  },\n  rangeDebug: (bs: Uint32Array, len: number, invert = false) =>\n    `[${Bitset.range(Bitset.indices(bs, len, invert))\n      .map((i) => `(${i.pos}/${i.length})`)\n      .join(', ')}]`,\n  setRange: (bs: Uint32Array, bsLen: number, pos: number, len: number, allowRewrite = true) => {\n    Bitset.chunkLen(bsLen, pos, len);\n    const { FULL_MASK, BITS } = Bitset;\n    // Try to set range with maximum efficiency:\n    // - first chunk is always    '0000[1111]' (only right ones)\n    // - middle chunks are set to '[1111 1111]' (all ones)\n    // - last chunk is always     '[1111]0000' (only left ones)\n    // - max operations:          (N/32) + 2 (first and last)\n    const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n    const lastPos = pos + len;\n    const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n    // special case, whole range inside single chunk\n    if (first !== undefined && first === last)\n      return Bitset.set(\n        bs,\n        first,\n        (FULL_MASK >>> (BITS - len)) << (BITS - len - pos),\n        allowRewrite\n      );\n    if (first !== undefined) {\n      if (!Bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite)) return false; // first chunk\n    }\n    // middle chunks\n    const start = first !== undefined ? first + 1 : pos / BITS;\n    const end = last !== undefined ? last : lastPos / BITS;\n    for (let i = start; i < end; i++) if (!Bitset.set(bs, i, FULL_MASK, allowRewrite)) return false;\n    if (last !== undefined && first !== last)\n      if (!Bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite)) return false; // last chunk\n    return true;\n  },\n};\n\n/** Path related utils (internal) */\ntype Path = { obj: StructOut; field?: string };\ntype PathStack = Path[];\nexport type _PathObjFn = (cb: (field: string, fieldFn: Function) => void) => void;\nconst Path = {\n  /**\n   * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n   * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n   * Also, this makes impossible:\n   * - pushing field when stack is empty\n   * - pushing field inside of field (real bug)\n   * NOTE: we don't want to do '.pop' on error!\n   */\n  pushObj: (stack: PathStack, obj: StructOut, objFn: _PathObjFn): void => {\n    const last: Path = { obj };\n    stack.push(last);\n    objFn((field: string, fieldFn: Function) => {\n      last.field = field;\n      fieldFn();\n      last.field = undefined;\n    });\n    stack.pop();\n  },\n  path: (stack: PathStack): string => {\n    const res = [];\n    for (const i of stack) if (i.field !== undefined) res.push(i.field);\n    return res.join('/');\n  },\n  err: (name: string, stack: PathStack, msg: string | Error): Error => {\n    const err = new Error(\n      `${name}(${Path.path(stack)}): ${typeof msg === 'string' ? msg : msg.message}`\n    );\n    if (msg instanceof Error && msg.stack) err.stack = msg.stack;\n    return err;\n  },\n  resolve: (stack: PathStack, path: string): StructOut | undefined => {\n    const parts = path.split('/');\n    const objPath = stack.map((i) => i.obj);\n    let i = 0;\n    for (; i < parts.length; i++) {\n      if (parts[i] === '..') objPath.pop();\n      else break;\n    }\n    let cur = objPath.pop();\n    for (; i < parts.length; i++) {\n      if (!cur || cur[parts[i]] === undefined) return undefined;\n      cur = cur[parts[i]];\n    }\n    return cur;\n  },\n};\n\n/**\n * Options for the Reader class.\n * @property {boolean} [allowUnreadBytes: false] - If there are remaining unparsed bytes, the decoding is probably wrong.\n * @property {boolean} [allowMultipleReads: false] - The check enforces parser termination. If pointers can read the same region of memory multiple times, you can cause combinatorial explosion by creating an array of pointers to the same address and cause DoS.\n */\nexport type ReaderOpts = {\n  allowUnreadBytes?: boolean;\n  allowMultipleReads?: boolean;\n};\n// These are safe API for external usage\nexport type Reader = {\n  // Utils\n  /** Current position in the buffer. */\n  readonly pos: number;\n  /** Number of bytes left in the buffer. */\n  readonly leftBytes: number;\n  /** Total number of bytes in the buffer. */\n  readonly totalBytes: number;\n  /** Checks if the end of the buffer has been reached. */\n  isEnd(): boolean;\n  /**\n   * Creates an error with the given message. Adds information about current field path.\n   * If Error object provided, saves original stack trace.\n   * @param msg - The error message or an Error object.\n   * @returns The created Error object.\n   */\n  err(msg: string | Error): Error;\n  /**\n   * Reads a specified number of bytes from the buffer.\n   *\n   * WARNING: Uint8Array is subarray of original buffer. Do not modify.\n   * @param n - The number of bytes to read.\n   * @param peek - If `true`, the bytes are read without advancing the position.\n   * @returns The read bytes as a Uint8Array.\n   */\n  bytes(n: number, peek?: boolean): Uint8Array;\n  /**\n   * Reads a single byte from the buffer.\n   * @param peek - If `true`, the byte is read without advancing the position.\n   * @returns The read byte as a number.\n   */\n  byte(peek?: boolean): number;\n  /**\n   * Reads a specified number of bits from the buffer.\n   * @param bits - The number of bits to read.\n   * @returns The read bits as a number.\n   */\n  bits(bits: number): number;\n  /**\n   * Finds the first occurrence of a needle in the buffer.\n   * @param needle - The needle to search for.\n   * @param pos - The starting position for the search.\n   * @returns The position of the first occurrence of the needle, or `undefined` if not found.\n   */\n  find(needle: Bytes, pos?: number): number | undefined;\n  /**\n   * Creates a new Reader instance at the specified offset.\n   * Complex and unsafe API: currently only used in eth ABI parsing of pointers.\n   * Required to break pointer boundaries inside arrays for complex structure.\n   * Please use only if absolutely necessary!\n   * @param n - The offset to create the new Reader at.\n   * @returns A new Reader instance at the specified offset.\n   */\n  offsetReader(n: number): Reader;\n};\n\nexport type Writer = {\n  /**\n   * Creates an error with the given message. Adds information about current field path.\n   * If Error object provided, saves original stack trace.\n   * @param msg - The error message or an Error object.\n   * @returns The created Error object.\n   */\n  err(msg: string | Error): Error;\n  /**\n   * Writes a byte array to the buffer.\n   * @param b - The byte array to write.\n   */\n  bytes(b: Bytes): void;\n  /**\n   * Writes a single byte to the buffer.\n   * @param b - The byte to write.\n   */\n  byte(b: number): void;\n  /**\n   * Writes a specified number of bits to the buffer.\n   * @param value - The value to write.\n   * @param bits - The number of bits to write.\n   */\n  bits(value: number, bits: number): void;\n};\n\n/**\n * Internal structure. Reader class for reading from a byte array.\n * `stack` is internal: for debugger and logging\n * @class Reader\n */\nclass _Reader implements Reader {\n  pos = 0;\n  readonly data: Bytes;\n  readonly opts: ReaderOpts;\n  readonly stack: PathStack;\n  private parent: _Reader | undefined;\n  private parentOffset: number;\n  private bitBuf = 0;\n  private bitPos = 0;\n  private bs: Uint32Array | undefined; // bitset\n  private view: DataView;\n  constructor(\n    data: Bytes,\n    opts: ReaderOpts = {},\n    stack: PathStack = [],\n    parent: _Reader | undefined = undefined,\n    parentOffset: number = 0\n  ) {\n    this.data = data;\n    this.opts = opts;\n    this.stack = stack;\n    this.parent = parent;\n    this.parentOffset = parentOffset;\n    this.view = createView(data);\n  }\n  /** Internal method for pointers. */\n  _enablePointers(): void {\n    if (this.parent) return this.parent._enablePointers();\n    if (this.bs) return;\n    this.bs = Bitset.create(this.data.length);\n    Bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n  }\n  private markBytesBS(pos: number, len: number): boolean {\n    if (this.parent) return this.parent.markBytesBS(this.parentOffset + pos, len);\n    if (!len) return true;\n    if (!this.bs) return true;\n    return Bitset.setRange(this.bs, this.data.length, pos, len, false);\n  }\n  private markBytes(len: number): boolean {\n    const pos = this.pos;\n    this.pos += len;\n    const res = this.markBytesBS(pos, len);\n    if (!this.opts.allowMultipleReads && !res)\n      throw this.err(`multiple read pos=${this.pos} len=${len}`);\n    return res;\n  }\n\n  pushObj(obj: StructOut, objFn: _PathObjFn): void {\n    return Path.pushObj(this.stack, obj, objFn);\n  }\n  readView(n: number, fn: (view: DataView, pos: number) => number): number {\n    if (!Number.isFinite(n)) throw this.err(`readView: wrong length=${n}`);\n    if (this.pos + n > this.data.length) throw this.err('readView: Unexpected end of buffer');\n    const res = fn(this.view, this.pos);\n    this.markBytes(n);\n    return res;\n  }\n  // read bytes by absolute offset\n  absBytes(n: number): Uint8Array {\n    if (n > this.data.length) throw new Error('Unexpected end of buffer');\n    return this.data.subarray(n);\n  }\n  finish(): void {\n    if (this.opts.allowUnreadBytes) return;\n    if (this.bitPos) {\n      throw this.err(\n        `${this.bitPos} bits left after unpack: ${baseHex.encode(this.data.slice(this.pos))}`\n      );\n    }\n    if (this.bs && !this.parent) {\n      const notRead = Bitset.indices(this.bs, this.data.length, true);\n      if (notRead.length) {\n        const formatted = Bitset.range(notRead)\n          .map(\n            ({ pos, length }) =>\n              `(${pos}/${length})[${baseHex.encode(this.data.subarray(pos, pos + length))}]`\n          )\n          .join(', ');\n        throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n      } else return; // all bytes read, everything is ok\n    }\n    // Default: no pointers enabled\n    if (!this.isEnd()) {\n      throw this.err(\n        `${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${baseHex.encode(\n          this.data.slice(this.pos)\n        )}`\n      );\n    }\n  }\n  // User methods\n  err(msg: string | Error): Error {\n    return Path.err('Reader', this.stack, msg);\n  }\n  offsetReader(n: number): _Reader {\n    if (n > this.data.length) throw this.err('offsetReader: Unexpected end of buffer');\n    return new _Reader(this.absBytes(n), this.opts, this.stack, this, n);\n  }\n  bytes(n: number, peek = false): Uint8Array {\n    if (this.bitPos) throw this.err('readBytes: bitPos not empty');\n    if (!Number.isFinite(n)) throw this.err(`readBytes: wrong length=${n}`);\n    if (this.pos + n > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n    const slice = this.data.subarray(this.pos, this.pos + n);\n    if (!peek) this.markBytes(n);\n    return slice;\n  }\n  byte(peek = false): number {\n    if (this.bitPos) throw this.err('readByte: bitPos not empty');\n    if (this.pos + 1 > this.data.length) throw this.err('readBytes: Unexpected end of buffer');\n    const data = this.data[this.pos];\n    if (!peek) this.markBytes(1);\n    return data;\n  }\n  get leftBytes(): number {\n    return this.data.length - this.pos;\n  }\n  get totalBytes(): number {\n    return this.data.length;\n  }\n  isEnd(): boolean {\n    return this.pos >= this.data.length && !this.bitPos;\n  }\n  // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n  bits(bits: number): number {\n    if (bits > 32) throw this.err('BitReader: cannot read more than 32 bits in single call');\n    let out = 0;\n    while (bits) {\n      if (!this.bitPos) {\n        this.bitBuf = this.byte();\n        this.bitPos = 8;\n      }\n      const take = Math.min(bits, this.bitPos);\n      this.bitPos -= take;\n      out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n      this.bitBuf &= 2 ** this.bitPos - 1;\n      bits -= take;\n    }\n    // Fix signed integers\n    return out >>> 0;\n  }\n  find(needle: Bytes, pos: number = this.pos): number | undefined {\n    if (!isBytes(needle)) throw this.err(`find: needle is not bytes! ${needle}`);\n    if (this.bitPos) throw this.err('findByte: bitPos not empty');\n    if (!needle.length) throw this.err(`find: needle is empty`);\n    // indexOf should be faster than full equalBytes check\n    for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n      if (idx === -1) return;\n      const leftBytes = this.data.length - idx;\n      if (leftBytes < needle.length) return;\n      if (equalBytes(needle, this.data.subarray(idx, idx + needle.length))) return idx;\n    }\n    return;\n  }\n}\n\n/**\n * Internal structure. Writer class for writing to a byte array.\n * The `stack` argument of constructor is internal, for debugging and logs.\n * @class Writer\n */\nclass _Writer implements Writer {\n  pos: number = 0;\n  readonly stack: PathStack;\n  // We could have a single buffer here and re-alloc it with\n  // x1.5-2 size each time it full, but it will be slower:\n  // basic/encode bench: 395ns -> 560ns\n  private buffers: Bytes[] = [];\n  ptrs: { pos: number; ptr: CoderType<number>; buffer: Bytes }[] = [];\n  private bitBuf = 0;\n  private bitPos = 0;\n  private viewBuf = new Uint8Array(8);\n  private view: DataView;\n  private finished = false;\n  constructor(stack: PathStack = []) {\n    this.stack = stack;\n    this.view = createView(this.viewBuf);\n  }\n  pushObj(obj: StructOut, objFn: _PathObjFn): void {\n    return Path.pushObj(this.stack, obj, objFn);\n  }\n  writeView(len: number, fn: (view: DataView) => void): void {\n    if (this.finished) throw this.err('buffer: finished');\n    if (!isNum(len) || len > 8) throw new Error(`wrong writeView length=${len}`);\n    fn(this.view);\n    this.bytes(this.viewBuf.slice(0, len));\n    this.viewBuf.fill(0);\n  }\n  // User methods\n  err(msg: string | Error): Error {\n    if (this.finished) throw this.err('buffer: finished');\n    return Path.err('Reader', this.stack, msg);\n  }\n  bytes(b: Bytes): void {\n    if (this.finished) throw this.err('buffer: finished');\n    if (this.bitPos) throw this.err('writeBytes: ends with non-empty bit buffer');\n    this.buffers.push(b);\n    this.pos += b.length;\n  }\n  byte(b: number): void {\n    if (this.finished) throw this.err('buffer: finished');\n    if (this.bitPos) throw this.err('writeByte: ends with non-empty bit buffer');\n    this.buffers.push(new Uint8Array([b]));\n    this.pos++;\n  }\n  finish(clean = true): Bytes {\n    if (this.finished) throw this.err('buffer: finished');\n    if (this.bitPos) throw this.err('buffer: ends with non-empty bit buffer');\n    // Can't use concatBytes, because it limits amount of arguments (65K).\n    const buffers = this.buffers.concat(this.ptrs.map((i) => i.buffer));\n    const sum = buffers.map((b) => b.length).reduce((a, b) => a + b, 0);\n    const buf = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < buffers.length; i++) {\n      const a = buffers[i];\n      buf.set(a, pad);\n      pad += a.length;\n    }\n\n    for (let pos = this.pos, i = 0; i < this.ptrs.length; i++) {\n      const ptr = this.ptrs[i];\n      buf.set(ptr.ptr.encode(pos), ptr.pos);\n      pos += ptr.buffer.length;\n    }\n    // Cleanup\n    if (clean) {\n      // We cannot cleanup buffers here, since it can be static user provided buffer.\n      // Only '.byte' and '.bits' create buffer which we can safely clean.\n      // for (const b of this.buffers) b.fill(0);\n      this.buffers = [];\n      for (const p of this.ptrs) p.buffer.fill(0);\n      this.ptrs = [];\n      this.finished = true;\n      this.bitBuf = 0;\n    }\n    return buf;\n  }\n  bits(value: number, bits: number): void {\n    if (bits > 32) throw this.err('writeBits: cannot write more than 32 bits in single call');\n    if (value >= 2 ** bits) throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n    while (bits) {\n      const take = Math.min(bits, 8 - this.bitPos);\n      this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n      this.bitPos += take;\n      bits -= take;\n      value &= 2 ** bits - 1;\n      if (this.bitPos === 8) {\n        this.bitPos = 0;\n        this.buffers.push(new Uint8Array([this.bitBuf]));\n        this.pos++;\n      }\n    }\n  }\n}\n// Immutable LE<->BE\nconst swapEndianness = (b: Bytes): Bytes => Uint8Array.from(b).reverse();\n/** Internal function for checking bit bounds of bigint in signed/unsinged form */\nfunction checkBounds(value: bigint, bits: bigint, signed: boolean): void {\n  if (signed) {\n    // [-(2**(32-1)), 2**(32-1)-1]\n    const signBit = 2n ** (bits - 1n);\n    if (value < -signBit || value >= signBit)\n      throw new Error(`value out of signed bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n  } else {\n    // [0, 2**32-1]\n    if (0n > value || value >= 2n ** bits)\n      throw new Error(`value out of unsigned bounds. Expected 0 <= ${value} < ${2n ** bits}`);\n  }\n}\n\nfunction _wrap<T>(inner: BytesCoderStream<T>): CoderType<T> {\n  return {\n    // NOTE: we cannot export validate here, since it is likely mistake.\n    encodeStream: inner.encodeStream,\n    decodeStream: inner.decodeStream,\n    size: inner.size,\n    encode: (value: T): Bytes => {\n      const w = new _Writer();\n      inner.encodeStream(w, value);\n      return w.finish();\n    },\n    decode: (data: Bytes, opts: ReaderOpts = {}): T => {\n      const r = new _Reader(data, opts);\n      const res = inner.decodeStream(r);\n      r.finish();\n      return res;\n    },\n  };\n}\n\n/**\n * Validates a value before encoding and after decoding using a provided function.\n * @param inner - The inner CoderType.\n * @param fn - The validation function.\n * @returns CoderType which check value with validation function.\n * @example\n * const val = (n: number) => {\n *   if (n > 10) throw new Error(`${n} > 10`);\n *   return n;\n * };\n *\n * const RangedInt = P.validate(P.U32LE, val); // Will check if value is <= 10 during encoding and decoding\n */\nexport function validate<T>(inner: CoderType<T>, fn: Validate<T>): CoderType<T> {\n  if (!isCoder(inner)) throw new Error(`validate: invalid inner value ${inner}`);\n  if (typeof fn !== 'function') throw new Error('validate: fn should be function');\n  return _wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, value: T) => {\n      let res;\n      try {\n        res = fn(value);\n      } catch (e) {\n        throw w.err(e as Error);\n      }\n      inner.encodeStream(w, res);\n    },\n    decodeStream: (r: Reader): T => {\n      const res = inner.decodeStream(r);\n      try {\n        return fn(res);\n      } catch (e) {\n        throw r.err(e as Error);\n      }\n    },\n  });\n}\n\n/**\n * Wraps a stream encoder into a generic encoder and optionally validation function\n * @param {inner} inner BytesCoderStream & { validate?: Validate<T> }.\n * @returns The wrapped CoderType.\n * @example\n * const U8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n * });\n * const checkedU8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n *   validate: (n: number) => {\n *    if (n > 10) throw new Error(`${n} > 10`);\n *    return n;\n *   }\n * });\n */\nexport const wrap = <T>(inner: BytesCoderStream<T> & { validate?: Validate<T> }): CoderType<T> => {\n  const res = _wrap(inner);\n  return inner.validate ? validate(res, inner.validate) : res;\n};\n\nconst isBaseCoder = (elm: any) =>\n  isPlainObject(elm) && typeof elm.decode === 'function' && typeof elm.encode === 'function';\n\n/**\n * Checks if the given value is a CoderType.\n * @param elm - The value to check.\n * @returns True if the value is a CoderType, false otherwise.\n */\nexport function isCoder<T>(elm: any): elm is CoderType<T> {\n  return (\n    isPlainObject(elm) &&\n    isBaseCoder(elm) &&\n    typeof elm.encodeStream === 'function' &&\n    typeof elm.decodeStream === 'function' &&\n    (elm.size === undefined || isNum(elm.size))\n  );\n}\n\n// Coders (like in @scure/base) for common operations\n\n/**\n * Base coder for working with dictionaries (records, objects, key-value map)\n * Dictionary is dynamic type like: `[key: string, value: any][]`\n * @returns base coder that encodes/decodes between arrays of key-value tuples and dictionaries.\n * @example\n * const dict: P.CoderType<Record<string, number>> = P.apply(\n *  P.array(P.U16BE, P.tuple([P.cstring, P.U32LE] as const)),\n *  P.coders.dict()\n * );\n */\nfunction dict<T>(): BaseCoder<[string, T][], Record<string, T>> {\n  return {\n    encode: (from: [string, T][]): Record<string, T> => {\n      if (!Array.isArray(from)) throw new Error('array expected');\n      const to: Record<string, T> = {};\n      for (const item of from) {\n        if (!Array.isArray(item) || item.length !== 2)\n          throw new Error(`array of two elements expected`);\n        const name = item[0];\n        const value = item[1];\n        if (to[name] !== undefined) throw new Error(`key(${name}) appears twice in struct`);\n        to[name] = value;\n      }\n      return to;\n    },\n    decode: (to: Record<string, T>): [string, T][] => {\n      if (!isPlainObject(to)) throw new Error(`expected plain object, got ${to}`);\n      return Object.entries(to);\n    },\n  };\n}\n/**\n * Safely converts bigint to number.\n * Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n * but we still can use them since real value will be smaller than u32\n */\nconst numberBigint: BaseCoder<bigint, number> = {\n  encode: (from: bigint): number => {\n    if (typeof from !== 'bigint') throw new Error(`expected bigint, got ${typeof from}`);\n    if (from > BigInt(Number.MAX_SAFE_INTEGER))\n      throw new Error(`element bigger than MAX_SAFE_INTEGER=${from}`);\n    return Number(from);\n  },\n  decode: (to: number): bigint => {\n    if (!isNum(to)) throw new Error('element is not a safe integer');\n    return BigInt(to);\n  },\n};\n// TODO: replace map with this?\ntype Enum = { [k: string]: number | string } & { [k: number]: string };\n// Doesn't return numeric keys, so it's fine\ntype EnumKeys<T extends Enum> = keyof T;\n/**\n * Base coder for working with TypeScript enums.\n * @param e - TypeScript enum.\n * @returns base coder that encodes/decodes between numbers and enum keys.\n * @example\n * enum Color { Red, Green, Blue }\n * const colorCoder = P.coders.tsEnum(Color);\n * colorCoder.encode(Color.Red); // 'Red'\n * colorCoder.decode('Green'); // 1\n */\nfunction tsEnum<T extends Enum>(e: T): BaseCoder<number, EnumKeys<T>> {\n  if (!isPlainObject(e)) throw new Error('plain object expected');\n  return {\n    encode: (from: number): string => {\n      if (!isNum(from) || !(from in e)) throw new Error(`wrong value ${from}`);\n      return e[from];\n    },\n    decode: (to: string): number => {\n      if (typeof to !== 'string') throw new Error(`wrong value ${typeof to}`);\n      return e[to] as number;\n    },\n  };\n}\n/**\n * Base coder for working with decimal numbers.\n * @param precision - Number of decimal places.\n * @param round - Round fraction part if bigger than precision (throws error by default)\n * @returns base coder that encodes/decodes between bigints and decimal strings.\n * @example\n * const decimal8 = P.coders.decimal(8);\n * decimal8.encode(630880845n); // '6.30880845'\n * decimal8.decode('6.30880845'); // 630880845n\n */\nfunction decimal(precision: number, round = false): Coder<bigint, string> {\n  if (!isNum(precision)) throw new Error(`decimal/precision: wrong value ${precision}`);\n  if (typeof round !== 'boolean')\n    throw new Error(`decimal/round: expected boolean, got ${typeof round}`);\n  const decimalMask = 10n ** BigInt(precision);\n  return {\n    encode: (from: bigint): string => {\n      if (typeof from !== 'bigint') throw new Error(`expected bigint, got ${typeof from}`);\n      let s = (from < 0n ? -from : from).toString(10);\n      let sep = s.length - precision;\n      if (sep < 0) {\n        s = s.padStart(s.length - sep, '0');\n        sep = 0;\n      }\n      let i = s.length - 1;\n      for (; i >= sep && s[i] === '0'; i--);\n      let int = s.slice(0, sep);\n      let frac = s.slice(sep, i + 1);\n      if (!int) int = '0';\n      if (from < 0n) int = '-' + int;\n      if (!frac) return int;\n      return `${int}.${frac}`;\n    },\n    decode: (to: string): bigint => {\n      if (typeof to !== 'string') throw new Error(`expected string, got ${typeof to}`);\n      if (to === '-0') throw new Error(`negative zero is not allowed`);\n      let neg = false;\n      if (to.startsWith('-')) {\n        neg = true;\n        to = to.slice(1);\n      }\n      if (!/^(0|[1-9]\\d*)(\\.\\d+)?$/.test(to)) throw new Error(`wrong string value=${to}`);\n      let sep = to.indexOf('.');\n      sep = sep === -1 ? to.length : sep;\n      // split by separator and strip trailing zeros from fraction. always returns [string, string] (.split doesn't).\n      const intS = to.slice(0, sep);\n      const fracS = to.slice(sep + 1).replace(/0+$/, '');\n      const int = BigInt(intS) * decimalMask;\n      if (!round && fracS.length > precision) {\n        throw new Error(\n          `fractional part cannot be represented with this precision (num=${to}, prec=${precision})`\n        );\n      }\n      const fracLen = Math.min(fracS.length, precision);\n      const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n      const value = int + frac;\n      return neg ? -value : value;\n    },\n  };\n}\n\n// TODO: export from @scure/base?\ntype BaseInput<F> = F extends BaseCoder<infer T, any> ? T : never;\ntype BaseOutput<F> = F extends BaseCoder<any, infer T> ? T : never;\n\n/**\n * Combines multiple coders into a single coder, allowing conditional encoding/decoding based on input.\n * Acts as a parser combinator, splitting complex conditional coders into smaller parts.\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * @param lst - Array of coders to match.\n * @returns Combined coder for conditional encoding/decoding.\n */\nfunction match<\n  L extends BaseCoder<unknown | undefined, unknown | undefined>[],\n  I = { [K in keyof L]: NonNullable<BaseInput<L[K]>> }[number],\n  O = { [K in keyof L]: NonNullable<BaseOutput<L[K]>> }[number],\n>(lst: L): BaseCoder<I, O> {\n  if (!Array.isArray(lst)) throw new Error(`expected array, got ${typeof lst}`);\n  for (const i of lst) if (!isBaseCoder(i)) throw new Error(`wrong base coder ${i}`);\n  return {\n    encode: (from: I): O => {\n      for (const c of lst) {\n        const elm = c.encode(from);\n        if (elm !== undefined) return elm as O;\n      }\n      throw new Error(`match/encode: cannot find match in ${from}`);\n    },\n    decode: (to: O): I => {\n      for (const c of lst) {\n        const elm = c.decode(to);\n        if (elm !== undefined) return elm as I;\n      }\n      throw new Error(`match/decode: cannot find match in ${to}`);\n    },\n  };\n}\n/** Reverses direction of coder */\nconst reverse = <F, T>(coder: Coder<F, T>): Coder<T, F> => {\n  if (!isBaseCoder(coder)) throw new Error('BaseCoder expected');\n  return { encode: coder.decode, decode: coder.encode };\n};\n\nexport const coders: {\n  dict: typeof dict;\n  numberBigint: BaseCoder<bigint, number>;\n  tsEnum: typeof tsEnum;\n  decimal: typeof decimal;\n  match: typeof match;\n  reverse: <F, T>(coder: Coder<F, T>) => Coder<T, F>;\n} = { dict, numberBigint, tsEnum, decimal, match, reverse };\n\n/**\n * CoderType for parsing individual bits.\n * NOTE: Structure should parse whole amount of bytes before it can start parsing byte-level elements.\n * @param len - Number of bits to parse.\n * @returns CoderType representing the parsed bits.\n * @example\n * const s = P.struct({ magic: P.bits(1), version: P.bits(1), tag: P.bits(4), len: P.bits(2) });\n */\nexport const bits = (len: number): CoderType<number> => {\n  if (!isNum(len)) throw new Error(`bits: wrong length ${len} (${typeof len})`);\n  return wrap({\n    encodeStream: (w: Writer, value: number) => w.bits(value, len),\n    decodeStream: (r: Reader): number => r.bits(len),\n    validate: (value) => {\n      if (!isNum(value)) throw new Error(`bits: wrong value ${value}`);\n      return value;\n    },\n  });\n};\n\n/**\n * CoderType for working with bigint values.\n * Unsized bigint values should be wrapped in a container (e.g., bytes or string).\n *\n * `0n = new Uint8Array([])`\n *\n * `1n = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the bigint in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the bigint is signed.\n * @param sized - Whether the bigint should have a fixed size.\n * @returns CoderType representing the bigint value.\n * @example\n * const U512BE = P.bigint(64, false, true, true); // Define a CoderType for a 512-bit unsigned big-endian integer\n */\nexport const bigint = (\n  size: number,\n  le = false,\n  signed = false,\n  sized = true\n): CoderType<bigint> => {\n  if (!isNum(size)) throw new Error(`bigint/size: wrong value ${size}`);\n  if (typeof le !== 'boolean') throw new Error(`bigint/le: expected boolean, got ${typeof le}`);\n  if (typeof signed !== 'boolean')\n    throw new Error(`bigint/signed: expected boolean, got ${typeof signed}`);\n  if (typeof sized !== 'boolean')\n    throw new Error(`bigint/sized: expected boolean, got ${typeof sized}`);\n  const bLen = BigInt(size);\n  const signBit = 2n ** (8n * bLen - 1n);\n  return wrap({\n    size: sized ? size : undefined,\n    encodeStream: (w: Writer, value: bigint) => {\n      if (signed && value < 0) value = value | signBit;\n      const b = [];\n      for (let i = 0; i < size; i++) {\n        b.push(Number(value & 255n));\n        value >>= 8n;\n      }\n      let res = new Uint8Array(b).reverse();\n      if (!sized) {\n        let pos = 0;\n        for (pos = 0; pos < res.length; pos++) if (res[pos] !== 0) break;\n        res = res.subarray(pos); // remove leading zeros\n      }\n      w.bytes(le ? res.reverse() : res);\n    },\n    decodeStream: (r: Reader): bigint => {\n      // TODO: for le we can read until first zero?\n      const value = r.bytes(sized ? size : Math.min(size, r.leftBytes));\n      const b = le ? value : swapEndianness(value);\n      let res = 0n;\n      for (let i = 0; i < b.length; i++) res |= BigInt(b[i]) << (8n * BigInt(i));\n      if (signed && res & signBit) res = (res ^ signBit) - signBit;\n      return res;\n    },\n    validate: (value) => {\n      if (typeof value !== 'bigint') throw new Error(`bigint: invalid value: ${value}`);\n      checkBounds(value, 8n * bLen, !!signed);\n      return value;\n    },\n  });\n};\n/** Unsigned 256-bit little-endian integer CoderType. */\nexport const U256LE: CoderType<bigint> = /* @__PURE__ */ bigint(32, true);\n/** Unsigned 256-bit big-endian integer CoderType. */\nexport const U256BE: CoderType<bigint> = /* @__PURE__ */ bigint(32, false);\n/** Signed 256-bit little-endian integer CoderType. */\nexport const I256LE: CoderType<bigint> = /* @__PURE__ */ bigint(32, true, true);\n/** Signed 256-bit big-endian integer CoderType. */\nexport const I256BE: CoderType<bigint> = /* @__PURE__ */ bigint(32, false, true);\n/** Unsigned 128-bit little-endian integer CoderType. */\nexport const U128LE: CoderType<bigint> = /* @__PURE__ */ bigint(16, true);\n/** Unsigned 128-bit big-endian integer CoderType. */\nexport const U128BE: CoderType<bigint> = /* @__PURE__ */ bigint(16, false);\n/** Signed 128-bit little-endian integer CoderType. */\nexport const I128LE: CoderType<bigint> = /* @__PURE__ */ bigint(16, true, true);\n/** Signed 128-bit big-endian integer CoderType. */\nexport const I128BE: CoderType<bigint> = /* @__PURE__ */ bigint(16, false, true);\n/** Unsigned 64-bit little-endian integer CoderType. */\nexport const U64LE: CoderType<bigint> = /* @__PURE__ */ bigint(8, true);\n/** Unsigned 64-bit big-endian integer CoderType. */\nexport const U64BE: CoderType<bigint> = /* @__PURE__ */ bigint(8, false);\n/** Signed 64-bit little-endian integer CoderType. */\nexport const I64LE: CoderType<bigint> = /* @__PURE__ */ bigint(8, true, true);\n/** Signed 64-bit big-endian integer CoderType. */\nexport const I64BE: CoderType<bigint> = /* @__PURE__ */ bigint(8, false, true);\n\n/**\n * CoderType for working with numbber values (up to 6 bytes/48 bits).\n * Unsized int values should be wrapped in a container (e.g., bytes or string).\n *\n * `0 = new Uint8Array([])`\n *\n * `1 = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the number in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the number is signed.\n * @param sized - Whether the number should have a fixed size.\n * @returns CoderType representing the number value.\n * @example\n * const uint64BE = P.bigint(8, false, true); // Define a CoderType for a 64-bit unsigned big-endian integer\n */\nexport const int = (size: number, le = false, signed = false, sized = true): CoderType<number> => {\n  if (!isNum(size)) throw new Error(`int/size: wrong value ${size}`);\n  if (typeof le !== 'boolean') throw new Error(`int/le: expected boolean, got ${typeof le}`);\n  if (typeof signed !== 'boolean')\n    throw new Error(`int/signed: expected boolean, got ${typeof signed}`);\n  if (typeof sized !== 'boolean')\n    throw new Error(`int/sized: expected boolean, got ${typeof sized}`);\n  if (size > 6) throw new Error('int supports size up to 6 bytes (48 bits): use bigints instead');\n  return apply(bigint(size, le, signed, sized), coders.numberBigint);\n};\n\ntype ViewCoder = {\n  read: (view: DataView, pos: number) => number;\n  write: (view: DataView, value: number) => void;\n  validate?: (value: number) => void;\n};\n\nconst view = (len: number, opts: ViewCoder) =>\n  wrap({\n    size: len,\n    encodeStream: (w, value: number) =>\n      (w as _Writer).writeView(len, (view) => opts.write(view, value)),\n    decodeStream: (r) => (r as _Reader).readView(len, opts.read),\n    validate: (value: number) => {\n      if (typeof value !== 'number')\n        throw new Error(`viewCoder: expected number, got ${typeof value}`);\n      if (opts.validate) opts.validate(value);\n      return value;\n    },\n  });\n\nconst intView = (len: number, signed: boolean, opts: ViewCoder) => {\n  const bits = len * 8;\n  const signBit = 2 ** (bits - 1);\n  // Inlined checkBounds for integer\n  const validateSigned = (value: number) => {\n    if (!isNum(value)) throw new Error(`sintView: value is not safe integer: ${value}`);\n    if (value < -signBit || value >= signBit) {\n      throw new Error(\n        `sintView: value out of bounds. Expected ${-signBit} <= ${value} < ${signBit}`\n      );\n    }\n  };\n  const maxVal = 2 ** bits;\n  const validateUnsigned = (value: number) => {\n    if (!isNum(value)) throw new Error(`uintView: value is not safe integer: ${value}`);\n    if (0 > value || value >= maxVal) {\n      throw new Error(`uintView: value out of bounds. Expected 0 <= ${value} < ${maxVal}`);\n    }\n  };\n  return view(len, {\n    write: opts.write,\n    read: opts.read,\n    validate: signed ? validateSigned : validateUnsigned,\n  });\n};\n\n/** Unsigned 32-bit little-endian integer CoderType. */\nexport const U32LE: CoderType<number> = /* @__PURE__ */ intView(4, false, {\n  read: (view, pos) => view.getUint32(pos, true),\n  write: (view, value) => view.setUint32(0, value, true),\n});\n/** Unsigned 32-bit big-endian integer CoderType. */\nexport const U32BE: CoderType<number> = /* @__PURE__ */ intView(4, false, {\n  read: (view, pos) => view.getUint32(pos, false),\n  write: (view, value) => view.setUint32(0, value, false),\n});\n/** Signed 32-bit little-endian integer CoderType. */\nexport const I32LE: CoderType<number> = /* @__PURE__ */ intView(4, true, {\n  read: (view, pos) => view.getInt32(pos, true),\n  write: (view, value) => view.setInt32(0, value, true),\n});\n/** Signed 32-bit big-endian integer CoderType. */\nexport const I32BE: CoderType<number> = /* @__PURE__ */ intView(4, true, {\n  read: (view, pos) => view.getInt32(pos, false),\n  write: (view, value) => view.setInt32(0, value, false),\n});\n/** Unsigned 16-bit little-endian integer CoderType. */\nexport const U16LE: CoderType<number> = /* @__PURE__ */ intView(2, false, {\n  read: (view, pos) => view.getUint16(pos, true),\n  write: (view, value) => view.setUint16(0, value, true),\n});\n/** Unsigned 16-bit big-endian integer CoderType. */\nexport const U16BE: CoderType<number> = /* @__PURE__ */ intView(2, false, {\n  read: (view, pos) => view.getUint16(pos, false),\n  write: (view, value) => view.setUint16(0, value, false),\n});\n/** Signed 16-bit little-endian integer CoderType. */\nexport const I16LE: CoderType<number> = /* @__PURE__ */ intView(2, true, {\n  read: (view, pos) => view.getInt16(pos, true),\n  write: (view, value) => view.setInt16(0, value, true),\n});\n/** Signed 16-bit big-endian integer CoderType. */\nexport const I16BE: CoderType<number> = /* @__PURE__ */ intView(2, true, {\n  read: (view, pos) => view.getInt16(pos, false),\n  write: (view, value) => view.setInt16(0, value, false),\n});\n/** Unsigned 8-bit integer CoderType. */\nexport const U8: CoderType<number> = /* @__PURE__ */ intView(1, false, {\n  read: (view, pos) => view.getUint8(pos),\n  write: (view, value) => view.setUint8(0, value),\n});\n/** Signed 8-bit integer CoderType. */\nexport const I8: CoderType<number> = /* @__PURE__ */ intView(1, true, {\n  read: (view, pos) => view.getInt8(pos),\n  write: (view, value) => view.setInt8(0, value),\n});\n\n// Floats\nconst f32 = (le?: boolean) =>\n  view(4, {\n    read: (view, pos) => view.getFloat32(pos, le),\n    write: (view, value) => view.setFloat32(0, value, le),\n    validate: (value) => {\n      if (Math.fround(value) !== value && !Number.isNaN(value))\n        throw new Error(`f32: wrong value=${value}`);\n    },\n  });\nconst f64 = (le?: boolean) =>\n  view(8, {\n    read: (view, pos) => view.getFloat64(pos, le),\n    write: (view, value) => view.setFloat64(0, value, le),\n  });\n\n/** 32-bit big-endian floating point CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32BE: CoderType<number> = /* @__PURE__ */ f32(false);\n/** 32-bit little-endian floating point  CoderType (\"binary32\", IEEE 754-2008). */\nexport const F32LE: CoderType<number> = /* @__PURE__ */ f32(true);\n/** A 64-bit big-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64BE: CoderType<number> = /* @__PURE__ */ f64(false);\n/** A 64-bit little-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexport const F64LE: CoderType<number> = /* @__PURE__ */ f64(true);\n\n/** Boolean CoderType. */\nexport const bool: CoderType<boolean> = /* @__PURE__ */ wrap({\n  size: 1,\n  encodeStream: (w: Writer, value: boolean) => w.byte(value ? 1 : 0),\n  decodeStream: (r: Reader): boolean => {\n    const value = r.byte();\n    if (value !== 0 && value !== 1) throw r.err(`bool: invalid value ${value}`);\n    return value === 1;\n  },\n  validate: (value) => {\n    if (typeof value !== 'boolean') throw new Error(`bool: invalid value ${value}`);\n    return value;\n  },\n});\n\n/**\n * Bytes CoderType with a specified length and endianness.\n * The bytes can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - CoderType, number, Uint8Array (terminator) or null\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the bytes.\n * @example\n * // Dynamic size bytes (prefixed with P.U16BE number of bytes length)\n * const dynamicBytes = P.bytes(P.U16BE, false);\n * const fixedBytes = P.bytes(32, false); // Fixed size bytes\n * const unknownBytes = P.bytes(null, false); // Unknown size bytes, will parse until end of buffer\n * const zeroTerminatedBytes = P.bytes(new Uint8Array([0]), false); // Zero-terminated bytes\n */\nconst createBytes = (len: Length, le = false): CoderType<Bytes> => {\n  if (typeof le !== 'boolean') throw new Error(`bytes/le: expected boolean, got ${typeof le}`);\n  const _length = lengthCoder(len);\n  const _isb = isBytes(len);\n  return wrap({\n    size: typeof len === 'number' ? len : undefined,\n    encodeStream: (w: Writer, value: Bytes) => {\n      if (!_isb) _length.encodeStream(w, value.length);\n      w.bytes(le ? swapEndianness(value) : value);\n      if (_isb) w.bytes(len);\n    },\n    decodeStream: (r: Reader): Bytes => {\n      let bytes: Bytes;\n      if (_isb) {\n        const tPos = r.find(len);\n        if (!tPos) throw r.err(`bytes: cannot find terminator`);\n        bytes = r.bytes(tPos - r.pos);\n        r.bytes(len.length);\n      } else {\n        bytes = r.bytes(len === null ? r.leftBytes : _length.decodeStream(r));\n      }\n      return le ? swapEndianness(bytes) : bytes;\n    },\n    validate: (value) => {\n      if (!isBytes(value)) throw new Error(`bytes: invalid value ${value}`);\n      return value;\n    },\n  });\n};\n\nexport { createBytes as bytes, createHex as hex };\n\n/**\n * Prefix-encoded value using a length prefix and an inner CoderType.\n * The prefix can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for the actual value to be prefix-encoded.\n * @returns CoderType representing the prefix-encoded value.\n * @example\n * const dynamicPrefix = P.prefix(P.U16BE, P.bytes(null)); // Dynamic size prefix (prefixed with P.U16BE number of bytes length)\n * const fixedPrefix = P.prefix(10, P.bytes(null)); // Fixed size prefix (always 10 bytes)\n */\nexport function prefix<T>(len: Length, inner: CoderType<T>): CoderType<T> {\n  if (!isCoder(inner)) throw new Error(`prefix: invalid inner value ${inner}`);\n  return apply(createBytes(len), reverse(inner)) as CoderType<T>;\n}\n\n/**\n * String CoderType with a specified length and endianness.\n * The string can be:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the string.\n * @example\n * const dynamicString = P.string(P.U16BE, false); // Dynamic size string (prefixed with P.U16BE number of string length)\n * const fixedString = P.string(10, false); // Fixed size string\n * const unknownString = P.string(null, false); // Unknown size string, will parse until end of buffer\n * const nullTerminatedString = P.cstring; // NUL-terminated string\n * const _cstring = P.string(new Uint8Array([0])); // Same thing\n */\nexport const string = (len: Length, le = false): CoderType<string> =>\n  validate(apply(createBytes(len, le), utf8), (value) => {\n    // TextEncoder/TextDecoder will fail on non-string, but we create more readable errors earlier\n    if (typeof value !== 'string') throw new Error(`expected string, got ${typeof value}`);\n    return value;\n  });\n\n/** NUL-terminated string CoderType. */\nexport const cstring: CoderType<string> = /* @__PURE__ */ string(NULL);\n\ntype HexOpts = { isLE?: boolean; with0x?: boolean };\n/**\n * Hexadecimal string CoderType with a specified length, endianness, and optional 0x prefix.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @param withZero - Whether to include the 0x prefix.\n * @returns CoderType representing the hexadecimal string.\n * @example\n * const dynamicHex = P.hex(P.U16BE, {isLE: false, with0x: true}); // Hex string with 0x prefix and U16BE length\n * const fixedHex = P.hex(32, {isLE: false, with0x: false}); // Fixed-length 32-byte hex string without 0x prefix\n */\nconst createHex = (\n  len: Length,\n  options: HexOpts = { isLE: false, with0x: false }\n): CoderType<string> => {\n  let inner = apply(createBytes(len, options.isLE), baseHex);\n  const prefix = options.with0x;\n  if (typeof prefix !== 'boolean')\n    throw new Error(`hex/with0x: expected boolean, got ${typeof prefix}`);\n  if (prefix) {\n    inner = apply(inner, {\n      encode: (value) => `0x${value}`,\n      decode: (value) => {\n        if (!value.startsWith('0x'))\n          throw new Error('hex(with0x=true).encode input should start with 0x');\n        return value.slice(2);\n      },\n    });\n  }\n  return inner;\n};\n\n/**\n * Applies a base coder to a CoderType.\n * @param inner - The inner CoderType.\n * @param b - The base coder to apply.\n * @returns CoderType representing the transformed value.\n * @example\n * import { hex } from '@scure/base';\n * const hex = P.apply(P.bytes(32), hex); // will decode bytes into a hex string\n */\nexport function apply<T, F>(inner: CoderType<T>, base: BaseCoder<T, F>): CoderType<F> {\n  if (!isCoder(inner)) throw new Error(`apply: invalid inner value ${inner}`);\n  if (!isBaseCoder(base)) throw new Error(`apply: invalid base value ${inner}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, value: F) => {\n      let innerValue;\n      try {\n        innerValue = base.decode(value);\n      } catch (e) {\n        throw w.err('' + e);\n      }\n      return inner.encodeStream(w, innerValue);\n    },\n    decodeStream: (r: Reader): F => {\n      const innerValue = inner.decodeStream(r);\n      try {\n        return base.encode(innerValue);\n      } catch (e) {\n        throw r.err('' + e);\n      }\n    },\n  });\n}\n\n/**\n * Lazy CoderType that is evaluated at runtime.\n * @param fn - A function that returns the CoderType.\n * @returns CoderType representing the lazy value.\n * @example\n * type Tree = { name: string; children: Tree[] };\n * const tree = P.struct({\n *   name: P.cstring,\n *   children: P.array(\n *     P.U16BE,\n *     P.lazy((): P.CoderType<Tree> => tree)\n *   ),\n * });\n */\nexport function lazy<T>(fn: () => CoderType<T>): CoderType<T> {\n  if (typeof fn !== 'function') throw new Error(`lazy: expected function, got ${typeof fn}`);\n  return wrap({\n    encodeStream: (w: Writer, value: T) => fn().encodeStream(w, value),\n    decodeStream: (r: Reader): T => fn().decodeStream(r),\n  });\n}\n\n/**\n * Flag CoderType that encodes/decodes a boolean value based on the presence of a marker.\n * @param flagValue - Marker value.\n * @param xor - Whether to invert the flag behavior.\n * @returns CoderType representing the flag value.\n * @example\n * const flag = P.flag(new Uint8Array([0x01, 0x02])); // Encodes true as u8a([0x01, 0x02]), false as u8a([])\n * const flagXor = P.flag(new Uint8Array([0x01, 0x02]), true); // Encodes true as u8a([]), false as u8a([0x01, 0x02])\n * // Conditional encoding with flagged\n * const s = P.struct({ f: P.flag(new Uint8Array([0x0, 0x1])), f2: P.flagged('f', P.U32BE) });\n */\nexport const flag = (flagValue: Bytes, xor = false): CoderType<boolean | undefined> => {\n  if (!isBytes(flagValue))\n    throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof flagValue}`);\n  if (typeof xor !== 'boolean') throw new Error(`flag/xor: expected boolean, got ${typeof xor}`);\n  return wrap({\n    size: flagValue.length,\n    encodeStream: (w: Writer, value: boolean | undefined) => {\n      if (!!value !== xor) w.bytes(flagValue);\n    },\n    decodeStream: (r: Reader): boolean | undefined => {\n      let hasFlag = r.leftBytes >= flagValue.length;\n      if (hasFlag) {\n        hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n        // Found flag, advance cursor position\n        if (hasFlag) r.bytes(flagValue.length);\n      }\n      return hasFlag !== xor; // hasFlag ^ xor\n    },\n    validate: (value) => {\n      if (value !== undefined && typeof value !== 'boolean')\n        throw new Error(`flag: expected boolean value or undefined, got ${typeof value}`);\n      return value;\n    },\n  });\n};\n\n/**\n * Conditional CoderType that encodes/decodes a value only if a flag is present.\n * @param path - Path to the flag value or a CoderType for the flag.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the conditional value.\n * @example\n * const s = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE)\n * });\n *\n * @example\n * const s2 = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE, 123)\n * });\n */\nexport function flagged<T>(\n  path: string | CoderType<boolean>,\n  inner: CoderType<T>,\n  def?: T\n): CoderType<Option<T>> {\n  if (!isCoder(inner)) throw new Error(`flagged: invalid inner value ${inner}`);\n  if (typeof path !== 'string' && !isCoder(inner)) throw new Error(`flagged: wrong path=${path}`);\n  return wrap({\n    encodeStream: (w: Writer, value: Option<T>) => {\n      if (typeof path === 'string') {\n        if (Path.resolve((w as _Writer).stack, path)) inner.encodeStream(w, value);\n        else if (def) inner.encodeStream(w, def);\n      } else {\n        path.encodeStream(w, !!value);\n        if (!!value) inner.encodeStream(w, value);\n        else if (def) inner.encodeStream(w, def);\n      }\n    },\n    decodeStream: (r: Reader): Option<T> => {\n      let hasFlag = false;\n      if (typeof path === 'string') hasFlag = !!Path.resolve((r as _Reader).stack, path);\n      else hasFlag = path.decodeStream(r);\n      // If there is a flag -- decode and return value\n      if (hasFlag) return inner.decodeStream(r);\n      else if (def) inner.decodeStream(r);\n      return;\n    },\n  });\n}\n/**\n * Optional CoderType that encodes/decodes a value based on a flag.\n * @param flag - CoderType for the flag value.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the optional value.\n * @example\n * // Will decode into P.U32BE only if flag present\n * const optional = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE);\n *\n * @example\n * // If no flag present, will decode into default value\n * const optionalWithDefault = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE, 123);\n */\nexport function optional<T>(\n  flag: CoderType<boolean>,\n  inner: CoderType<T>,\n  def?: T\n): CoderType<Option<T>> {\n  if (!isCoder(flag) || !isCoder(inner))\n    throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n  return wrap({\n    size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n    encodeStream: (w: Writer, value: Option<T>) => {\n      flag.encodeStream(w, !!value);\n      if (value) inner.encodeStream(w, value);\n      else if (def !== undefined) inner.encodeStream(w, def);\n    },\n    decodeStream: (r: Reader): Option<T> => {\n      if (flag.decodeStream(r)) return inner.decodeStream(r);\n      else if (def !== undefined) inner.decodeStream(r);\n      return;\n    },\n  });\n}\n/**\n * Magic value CoderType that encodes/decodes a constant value.\n * This can be used to check for a specific magic value or sequence of bytes at the beginning of a data structure.\n * @param inner - Inner CoderType for the value.\n * @param constant - Constant value.\n * @param check - Whether to check the decoded value against the constant.\n * @returns CoderType representing the magic value.\n * @example\n * // Always encodes constant as bytes using inner CoderType, throws if encoded value is not present\n * const magicU8 = P.magic(P.U8, 0x42);\n */\nexport function magic<T>(inner: CoderType<T>, constant: T, check = true): CoderType<undefined> {\n  if (!isCoder(inner)) throw new Error(`magic: invalid inner value ${inner}`);\n  if (typeof check !== 'boolean') throw new Error(`magic: expected boolean, got ${typeof check}`);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, _value: undefined) => inner.encodeStream(w, constant),\n    decodeStream: (r: Reader): undefined => {\n      const value = inner.decodeStream(r);\n      if (\n        (check && typeof value !== 'object' && value !== constant) ||\n        (isBytes(constant) && !equalBytes(constant, value as any))\n      ) {\n        throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n      }\n      return;\n    },\n    validate: (value) => {\n      if (value !== undefined) throw new Error(`magic: wrong value=${typeof value}`);\n      return value;\n    },\n  });\n}\n/**\n * Magic bytes CoderType that encodes/decodes a constant byte array or string.\n * @param constant - Constant byte array or string.\n * @returns CoderType representing the magic bytes.\n * @example\n * // Always encodes undefined into byte representation of string 'MAGIC'\n * const magicBytes = P.magicBytes('MAGIC');\n */\nexport const magicBytes = (constant: Bytes | string): CoderType<undefined> => {\n  const c = typeof constant === 'string' ? utf8.decode(constant) : constant;\n  return magic(createBytes(c.length), c);\n};\n\n/**\n * Creates a CoderType for a constant value. The function enforces this value during encoding,\n * ensuring it matches the provided constant. During decoding, it always returns the constant value.\n * The actual value is not written to or read from any byte stream; it's used only for validation.\n *\n * @param c - Constant value.\n * @returns CoderType representing the constant value.\n * @example\n * // Always return 123 on decode, throws on encoding anything other than 123\n * const constantU8 = P.constant(123);\n */\nexport function constant<T>(c: T): CoderType<T> {\n  return wrap({\n    encodeStream: (_w: Writer, value: T) => {\n      if (value !== c) throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n    },\n    decodeStream: (_r: Reader): T => c,\n  });\n}\n\nfunction sizeof(fields: CoderType<any>[]): Option<number> {\n  let size: Option<number> = 0;\n  for (const f of fields) {\n    if (f.size === undefined) return;\n    if (!isNum(f.size)) throw new Error(`sizeof: wrong element size=${size}`);\n    size += f.size;\n  }\n  return size;\n}\n/**\n * Structure of composable primitives (C/Rust struct)\n * @param fields - Object mapping field names to CoderTypes.\n * @returns CoderType representing the structure.\n * @example\n * // Define a structure with a 32-bit big-endian unsigned integer, a string, and a nested structure\n * const myStruct = P.struct({\n *   id: P.U32BE,\n *   name: P.string(P.U8),\n *   nested: P.struct({\n *     flag: P.bool,\n *     value: P.I16LE\n *   })\n * });\n */\nexport function struct<T extends Record<string, any>>(\n  fields: StructRecord<T>\n): CoderType<StructInput<T>> {\n  if (!isPlainObject(fields)) throw new Error(`struct: expected plain object, got ${fields}`);\n  for (const name in fields) {\n    if (!isCoder(fields[name])) throw new Error(`struct: field ${name} is not CoderType`);\n  }\n  return wrap({\n    size: sizeof(Object.values(fields)),\n    encodeStream: (w: Writer, value: StructInput<T>) => {\n      (w as _Writer).pushObj(value, (fieldFn) => {\n        for (const name in fields)\n          fieldFn(name, () => fields[name].encodeStream(w, (value as T)[name]));\n      });\n    },\n    decodeStream: (r: Reader): StructInput<T> => {\n      const res: Partial<T> = {};\n      (r as _Reader).pushObj(res, (fieldFn) => {\n        for (const name in fields) fieldFn(name, () => (res[name] = fields[name].decodeStream(r)));\n      });\n      return res as T;\n    },\n    validate: (value) => {\n      if (typeof value !== 'object' || value === null)\n        throw new Error(`struct: invalid value ${value}`);\n      return value;\n    },\n  });\n}\n/**\n * Tuple (unnamed structure) of CoderTypes. Same as struct but with unnamed fields.\n * @param fields - Array of CoderTypes.\n * @returns CoderType representing the tuple.\n * @example\n * const myTuple = P.tuple([P.U8, P.U16LE, P.string(P.U8)]);\n */\nexport function tuple<\n  T extends ArrLike<CoderType<any>>,\n  O = Writable<{ [K in keyof T]: UnwrapCoder<T[K]> }>,\n>(fields: T): CoderType<O> {\n  if (!Array.isArray(fields))\n    throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n  for (let i = 0; i < fields.length; i++) {\n    if (!isCoder(fields[i])) throw new Error(`tuple: field ${i} is not CoderType`);\n  }\n  return wrap({\n    size: sizeof(fields),\n    encodeStream: (w: Writer, value: O) => {\n      // TODO: fix types\n      if (!Array.isArray(value)) throw w.err(`tuple: invalid value ${value}`);\n      (w as _Writer).pushObj(value, (fieldFn) => {\n        for (let i = 0; i < fields.length; i++)\n          fieldFn(`${i}`, () => fields[i].encodeStream(w, value[i]));\n      });\n    },\n    decodeStream: (r: Reader): O => {\n      const res: any = [];\n      (r as _Reader).pushObj(res, (fieldFn) => {\n        for (let i = 0; i < fields.length; i++)\n          fieldFn(`${i}`, () => res.push(fields[i].decodeStream(r)));\n      });\n      return res;\n    },\n    validate: (value) => {\n      if (!Array.isArray(value)) throw new Error(`tuple: invalid value ${value}`);\n      if (value.length !== fields.length)\n        throw new Error(`tuple: wrong length=${value.length}, expected ${fields.length}`);\n      return value;\n    },\n  });\n}\n\n/**\n * Array of items (inner type) with a specified length.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for encoding/decoding each array item.\n * @returns CoderType representing the array.\n * @example\n * const a1 = P.array(P.U16BE, child); // Dynamic size array (prefixed with P.U16BE number of array length)\n * const a2 = P.array(4, child); // Fixed size array\n * const a3 = P.array(null, child); // Unknown size array, will parse until end of buffer\n * const a4 = P.array(new Uint8Array([0]), child); // zero-terminated array (NOTE: terminator can be any buffer)\n */\nexport function array<T>(len: Length, inner: CoderType<T>): CoderType<T[]> {\n  if (!isCoder(inner)) throw new Error(`array: invalid inner value ${inner}`);\n  // By construction length is inside array (otherwise there will be various incorrect stack states)\n  // But forcing users always write '..' seems like bad idea. Also, breaking change.\n  const _length = lengthCoder(typeof len === 'string' ? `../${len}` : len);\n  return wrap({\n    size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n    encodeStream: (w: Writer, value: T[]) => {\n      const _w = w as _Writer;\n      _w.pushObj(value, (fieldFn) => {\n        if (!isBytes(len)) _length.encodeStream(w, value.length);\n        for (let i = 0; i < value.length; i++) {\n          fieldFn(`${i}`, () => {\n            const elm = value[i];\n            const startPos = (w as _Writer).pos;\n            inner.encodeStream(w, elm);\n            if (isBytes(len)) {\n              // Terminator is bigger than elm size, so skip\n              if (len.length > _w.pos - startPos) return;\n              const data = _w.finish(false).subarray(startPos, _w.pos);\n              // There is still possible case when multiple elements create terminator,\n              // but it is hard to catch here, will be very slow\n              if (equalBytes(data.subarray(0, len.length), len))\n                throw _w.err(\n                  `array: inner element encoding same as separator. elm=${elm} data=${data}`\n                );\n            }\n          });\n        }\n      });\n      if (isBytes(len)) w.bytes(len);\n    },\n    decodeStream: (r: Reader): T[] => {\n      const res: T[] = [];\n      (r as _Reader).pushObj(res, (fieldFn) => {\n        if (len === null) {\n          for (let i = 0; !r.isEnd(); i++) {\n            fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n            if (inner.size && r.leftBytes < inner.size) break;\n          }\n        } else if (isBytes(len)) {\n          for (let i = 0; ; i++) {\n            if (equalBytes(r.bytes(len.length, true), len)) {\n              // Advance cursor position if terminator found\n              r.bytes(len.length);\n              break;\n            }\n            fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n          }\n        } else {\n          let length: number;\n          fieldFn('arrayLen', () => (length = _length.decodeStream(r)));\n          for (let i = 0; i < length!; i++) fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n        }\n      });\n      return res;\n    },\n    validate: (value) => {\n      if (!Array.isArray(value)) throw new Error(`array: invalid value ${value}`);\n      return value;\n    },\n  });\n}\n/**\n * Mapping between encoded values and string representations.\n * @param inner - CoderType for encoded values.\n * @param variants - Object mapping string representations to encoded values.\n * @returns CoderType representing the mapping.\n * @example\n * // Map between numbers and strings\n * const numberMap = P.map(P.U8, {\n *   'one': 1,\n *   'two': 2,\n *   'three': 3\n * });\n *\n * // Map between byte arrays and strings\n * const byteMap = P.map(P.bytes(2, false), {\n *   'ab': Uint8Array.from([0x61, 0x62]),\n *   'cd': Uint8Array.from([0x63, 0x64])\n * });\n */\nexport function map<T>(inner: CoderType<T>, variants: Record<string, T>): CoderType<string> {\n  if (!isCoder(inner)) throw new Error(`map: invalid inner value ${inner}`);\n  if (!isPlainObject(variants)) throw new Error(`map: variants should be plain object`);\n  const variantNames: Map<T, string> = new Map();\n  for (const k in variants) variantNames.set(variants[k], k);\n  return wrap({\n    size: inner.size,\n    encodeStream: (w: Writer, value: string) => inner.encodeStream(w, variants[value]),\n    decodeStream: (r: Reader): string => {\n      const variant = inner.decodeStream(r);\n      const name = variantNames.get(variant);\n      if (name === undefined)\n        throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n      return name;\n    },\n    validate: (value) => {\n      if (typeof value !== 'string') throw new Error(`map: invalid value ${value}`);\n      if (!(value in variants)) throw new Error(`Map: unknown variant: ${value}`);\n      return value;\n    },\n  });\n}\n/**\n * Tagged union of CoderTypes, where the tag value determines which CoderType to use.\n * The decoded value will have the structure `{ TAG: number, data: ... }`.\n * @param tag - CoderType for the tag value.\n * @param variants - Object mapping tag values to CoderTypes.\n * @returns CoderType representing the tagged union.\n * @example\n * // Tagged union of array, string, and number\n * // Depending on the value of the first byte, it will be decoded as an array, string, or number.\n * const taggedUnion = P.tag(P.U8, {\n *   0x01: P.array(P.U16LE, P.U8),\n *   0x02: P.string(P.U8),\n *   0x03: P.U32BE\n * });\n *\n * const encoded = taggedUnion.encode({ TAG: 0x01, data: 'hello' }); // Encodes the string 'hello' with tag 0x01\n * const decoded = taggedUnion.decode(encoded); // Decodes the encoded value back to { TAG: 0x01, data: 'hello' }\n */\nexport function tag<\n  T extends Values<{\n    [P in keyof Variants]: { TAG: P; data: UnwrapCoder<Variants[P]> };\n  }>,\n  TagValue extends string | number,\n  Variants extends Record<TagValue, CoderType<any>>,\n>(tag: CoderType<TagValue>, variants: Variants): CoderType<T> {\n  if (!isCoder(tag)) throw new Error(`tag: invalid tag value ${tag}`);\n  if (!isPlainObject(variants)) throw new Error(`tag: variants should be plain object`);\n  for (const name in variants) {\n    if (!isCoder(variants[name])) throw new Error(`tag: variant ${name} is not CoderType`);\n  }\n  return wrap({\n    size: tag.size,\n    encodeStream: (w: Writer, value: T) => {\n      const { TAG, data } = value;\n      const dataType = variants[TAG];\n      tag.encodeStream(w, TAG as any);\n      dataType.encodeStream(w, data);\n    },\n    decodeStream: (r: Reader): T => {\n      const TAG = tag.decodeStream(r);\n      const dataType = variants[TAG];\n      if (!dataType) throw r.err(`Tag: invalid tag ${TAG}`);\n      return { TAG, data: dataType.decodeStream(r) } as any;\n    },\n    validate: (value) => {\n      const { TAG } = value;\n      const dataType = variants[TAG];\n      if (!dataType) throw new Error(`Tag: invalid tag ${TAG.toString()}`);\n      return value;\n    },\n  });\n}\n\n/**\n * Mapping between encoded values, string representations, and CoderTypes using a tag CoderType.\n * @param tagCoder - CoderType for the tag value.\n * @param variants - Object mapping string representations to [tag value, CoderType] pairs.\n *  * @returns CoderType representing the mapping.\n * @example\n * const cborValue: P.CoderType<CborValue> = P.mappedTag(P.bits(3), {\n *   uint: [0, cborUint], // An unsigned integer in the range 0..264-1 inclusive.\n *   negint: [1, cborNegint], // A negative integer in the range -264..-1 inclusive\n *   bytes: [2, P.lazy(() => cborLength(P.bytes, cborValue))], // A byte string.\n *   string: [3, P.lazy(() => cborLength(P.string, cborValue))], // A text string (utf8)\n *   array: [4, cborArrLength(P.lazy(() => cborValue))], // An array of data items\n *   map: [5, P.lazy(() => cborArrLength(P.tuple([cborValue, cborValue])))], // A map of pairs of data items\n *   tag: [6, P.tuple([cborUint, P.lazy(() => cborValue)] as const)], // A tagged data item (\"tag\") whose tag number\n *   simple: [7, cborSimple], // Floating-point numbers and simple values, as well as the \"break\" stop code\n * });\n */\nexport function mappedTag<\n  T extends Values<{\n    [P in keyof Variants]: { TAG: P; data: UnwrapCoder<Variants[P][1]> };\n  }>,\n  TagValue extends string | number,\n  Variants extends Record<string, [TagValue, CoderType<any>]>,\n>(tagCoder: CoderType<TagValue>, variants: Variants): CoderType<T> {\n  if (!isCoder(tagCoder)) throw new Error(`mappedTag: invalid tag value ${tag}`);\n  if (!isPlainObject(variants)) throw new Error(`mappedTag: variants should be plain object`);\n  const mapValue: Record<string, TagValue> = {};\n  const tagValue: Record<string, CoderType<any>> = {};\n  for (const key in variants) {\n    const v = variants[key];\n    mapValue[key] = v[0];\n    tagValue[key] = v[1];\n  }\n  return tag(map(tagCoder, mapValue), tagValue) as any as CoderType<T>;\n}\n\n/**\n * Bitset of boolean values with optional padding.\n * @param names - An array of string names for the bitset values.\n * @param pad - Whether to pad the bitset to a multiple of 8 bits.\n * @returns CoderType representing the bitset.\n * @template Names\n * @example\n * const myBitset = P.bitset(['flag1', 'flag2', 'flag3', 'flag4'], true);\n */\nexport function bitset<Names extends readonly string[]>(\n  names: Names,\n  pad = false\n): CoderType<Record<Names[number], boolean>> {\n  if (typeof pad !== 'boolean') throw new Error(`bitset/pad: expected boolean, got ${typeof pad}`);\n  if (!Array.isArray(names)) throw new Error('bitset/names: expected array');\n  for (const name of names) {\n    if (typeof name !== 'string') throw new Error('bitset/names: expected array of strings');\n  }\n  return wrap({\n    encodeStream: (w: Writer, value: Record<Names[number], boolean>) => {\n      for (let i = 0; i < names.length; i++) w.bits(+(value as any)[names[i]], 1);\n      if (pad && names.length % 8) w.bits(0, 8 - (names.length % 8));\n    },\n    decodeStream: (r: Reader): Record<Names[number], boolean> => {\n      const out: Record<string, boolean> = {};\n      for (let i = 0; i < names.length; i++) out[names[i]] = !!r.bits(1);\n      if (pad && names.length % 8) r.bits(8 - (names.length % 8));\n      return out;\n    },\n    validate: (value) => {\n      if (!isPlainObject(value)) throw new Error(`bitset: invalid value ${value}`);\n      for (const v of Object.values(value)) {\n        if (typeof v !== 'boolean') throw new Error('expected boolean');\n      }\n      return value;\n    },\n  });\n}\n/** Padding function which always returns zero */\nexport const ZeroPad: PadFn = (_) => 0;\n\nfunction padLength(blockSize: number, len: number): number {\n  if (len % blockSize === 0) return 0;\n  return blockSize - (len % blockSize);\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the left side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U32BE with a block size of 4 and zero padding\n * const paddedU32BE = P.padLeft(4, P.U32BE);\n *\n * // Pad a string with a block size of 16 and custom padding\n * const paddedString = P.padLeft(16, P.string(P.U8), (i) => i + 1);\n */\nexport function padLeft<T>(\n  blockSize: number,\n  inner: CoderType<T>,\n  padFn: Option<PadFn>\n): CoderType<T> {\n  if (!isNum(blockSize) || blockSize <= 0) throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n  if (!isCoder(inner)) throw new Error(`padLeft: invalid inner value ${inner}`);\n  if (padFn !== undefined && typeof padFn !== 'function')\n    throw new Error(`padLeft: wrong padFn=${typeof padFn}`);\n  const _padFn = padFn || ZeroPad;\n  if (!inner.size) throw new Error('padLeft cannot have dynamic size');\n  return wrap({\n    size: inner.size + padLength(blockSize, inner.size),\n    encodeStream: (w: Writer, value: T) => {\n      const padBytes = padLength(blockSize, inner.size!);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n      inner.encodeStream(w, value);\n    },\n    decodeStream: (r: Reader): T => {\n      r.bytes(padLength(blockSize, inner.size!));\n      return inner.decodeStream(r);\n    },\n  });\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the right side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U16BE with a block size of 2 and zero padding\n * const paddedU16BE = P.padRight(2, P.U16BE);\n *\n * // Pad a bytes with a block size of 8 and custom padding\n * const paddedBytes = P.padRight(8, P.bytes(null), (i) => i + 1);\n */\nexport function padRight<T>(\n  blockSize: number,\n  inner: CoderType<T>,\n  padFn: Option<PadFn>\n): CoderType<T> {\n  if (!isCoder(inner)) throw new Error(`padRight: invalid inner value ${inner}`);\n  if (!isNum(blockSize) || blockSize <= 0) throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n  if (padFn !== undefined && typeof padFn !== 'function')\n    throw new Error(`padRight: wrong padFn=${typeof padFn}`);\n  const _padFn = padFn || ZeroPad;\n  return wrap({\n    size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n    encodeStream: (w: Writer, value: T) => {\n      const _w = w as _Writer;\n      const pos = _w.pos;\n      inner.encodeStream(w, value);\n      const padBytes = padLength(blockSize, _w.pos - pos);\n      for (let i = 0; i < padBytes; i++) w.byte(_padFn(i));\n    },\n    decodeStream: (r: Reader): T => {\n      const start = r.pos;\n      const res = inner.decodeStream(r);\n      r.bytes(padLength(blockSize, r.pos - start));\n      return res;\n    },\n  });\n}\n1;\n/**\n * Pointer to a value using a pointer CoderType and an inner CoderType.\n * Pointers are scoped, and the next pointer in the dereference chain is offset by the previous one.\n * By default (if no 'allowMultipleReads' in ReaderOpts is set) is safe, since\n * same region of memory cannot be read multiple times.\n * @param ptr - CoderType for the pointer value.\n * @param inner - CoderType for encoding/decoding the pointed value.\n * @param sized - Whether the pointer should have a fixed size.\n * @returns CoderType representing the pointer to the value.\n * @example\n * const pointerToU8 = P.pointer(P.U16BE, P.U8); // Pointer to a single U8 value\n */\nexport function pointer<T>(\n  ptr: CoderType<number>,\n  inner: CoderType<T>,\n  sized = false\n): CoderType<T> {\n  if (!isCoder(ptr)) throw new Error(`pointer: invalid ptr value ${ptr}`);\n  if (!isCoder(inner)) throw new Error(`pointer: invalid inner value ${inner}`);\n  if (typeof sized !== 'boolean')\n    throw new Error(`pointer/sized: expected boolean, got ${typeof sized}`);\n  if (!ptr.size) throw new Error('unsized pointer');\n  return wrap({\n    size: sized ? ptr.size : undefined,\n    encodeStream: (w: Writer, value: T) => {\n      const _w = w as _Writer;\n      const start = _w.pos;\n      ptr.encodeStream(w, 0);\n      _w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n    },\n    decodeStream: (r: Reader): T => {\n      const ptrVal = ptr.decodeStream(r);\n      (r as _Reader)._enablePointers();\n      return inner.decodeStream(r.offsetReader(ptrVal));\n    },\n  });\n}\n\n// Internal methods for test purposes only\nexport const _TEST: {\n  _bitset: {\n    BITS: number;\n    FULL_MASK: number;\n    len: (len: number) => number;\n    create: (len: number) => Uint32Array;\n    clean: (bs: Uint32Array) => Uint32Array;\n    debug: (bs: Uint32Array) => string[];\n    checkLen: (bs: Uint32Array, len: number) => void;\n    chunkLen: (bsLen: number, pos: number, len: number) => void;\n    set: (bs: Uint32Array, chunk: number, value: number, allowRewrite?: boolean) => boolean;\n    pos: (\n      pos: number,\n      i: number\n    ) => {\n      chunk: number;\n      mask: number;\n    };\n    indices: (bs: Uint32Array, len: number, invert?: boolean) => number[];\n    range: (arr: number[]) => {\n      pos: number;\n      length: number;\n    }[];\n    rangeDebug: (bs: Uint32Array, len: number, invert?: boolean) => string;\n    setRange: (\n      bs: Uint32Array,\n      bsLen: number,\n      pos: number,\n      len: number,\n      allowRewrite?: boolean\n    ) => boolean;\n  };\n  _Reader: typeof _Reader;\n  _Writer: typeof _Writer;\n  Path: {\n    /**\n     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n     * Also, this makes impossible:\n     * - pushing field when stack is empty\n     * - pushing field inside of field (real bug)\n     * NOTE: we don't want to do '.pop' on error!\n     */\n    pushObj: (stack: PathStack, obj: StructOut, objFn: _PathObjFn) => void;\n    path: (stack: PathStack) => string;\n    err(name: string, stack: PathStack, msg: string | Error): Error;\n    resolve: (stack: PathStack, path: string) => StructOut | undefined;\n  };\n} = { _bitset: Bitset, _Reader, _Writer, Path };\n", "import { schnorr, secp256k1 as secp } from '@noble/curves/secp256k1.js';\nimport { ripemd160 } from '@noble/hashes/legacy.js';\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { utils as packedUtils, U32LE } from 'micro-packed';\n\nexport type Hex = string | Uint8Array;\nexport type Bytes = Uint8Array;\nconst Point = secp.ProjectivePoint;\nconst CURVE_ORDER = secp.CURVE.n;\n\nconst isBytes: (a: unknown) => a is Uint8Array = packedUtils.isBytes;\nconst concatBytes: (...arrays: Uint8Array[]) => Uint8Array = packedUtils.concatBytes;\nconst equalBytes: (a: Uint8Array, b: Uint8Array) => boolean = packedUtils.equalBytes;\nexport { concatBytes, equalBytes, isBytes, sha256 };\n\nexport const hash160 = (msg: Uint8Array): Uint8Array => ripemd160(sha256(msg));\nexport const sha256x2 = (...msgs: Uint8Array[]): Uint8Array => sha256(sha256(concatBytes(...msgs)));\nexport const randomPrivateKeyBytes: () => Uint8Array = schnorr.utils.randomPrivateKey;\nexport const pubSchnorr = schnorr.getPublicKey as (priv: string | Uint8Array) => Uint8Array;\nexport const pubECDSA: (privateKey: string | Uint8Array, isCompressed?: boolean) => Uint8Array =\n  secp.getPublicKey;\n\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it's common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig: { r: bigint; s: bigint }) => sig.r < CURVE_ORDER / 2n;\nexport function signECDSA(hash: Bytes, privateKey: Bytes, lowR = false): Bytes {\n  let sig = secp.sign(hash, privateKey);\n  if (lowR && !hasLowR(sig)) {\n    const extraEntropy = new Uint8Array(32);\n    let counter = 0;\n    while (!hasLowR(sig)) {\n      extraEntropy.set(U32LE.encode(counter++));\n      sig = secp.sign(hash, privateKey, { extraEntropy });\n      if (counter > 4294967295) throw new Error('lowR counter overflow: report the error');\n    }\n  }\n  return sig.toDERRawBytes();\n}\n\nexport const signSchnorr: typeof schnorr.sign = schnorr.sign;\nexport const tagSchnorr: typeof schnorr.utils.taggedHash = schnorr.utils.taggedHash;\n\nexport enum PubT {\n  ecdsa,\n  schnorr,\n}\nexport function validatePubkey(pub: Bytes, type: PubT): Bytes {\n  const len = pub.length;\n  if (type === PubT.ecdsa) {\n    if (len === 32) throw new Error('Expected non-Schnorr key');\n    Point.fromHex(pub); // does assertValidity\n    return pub;\n  } else if (type === PubT.schnorr) {\n    if (len !== 32) throw new Error('Expected 32-byte Schnorr key');\n    schnorr.utils.lift_x(schnorr.utils.bytesToNumberBE(pub));\n    return pub;\n  } else {\n    throw new Error('Unknown key type');\n  }\n}\n\nexport function tapTweak(a: Bytes, b: Bytes): bigint {\n  const u = schnorr.utils;\n  const t = u.taggedHash('TapTweak', a, b);\n  const tn = u.bytesToNumberBE(t);\n  if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');\n  return tn;\n}\n\nexport function taprootTweakPrivKey(privKey: Bytes, merkleRoot: Bytes = Uint8Array.of()): Bytes {\n  const u = schnorr.utils;\n  const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n  const P = Point.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n  // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n  const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n  const xP = u.pointToBytes(P);\n  // t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n  const t = tapTweak(xP, merkleRoot);\n  // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n  return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\n\nexport function taprootTweakPubkey(pubKey: Bytes, h: Bytes): [Bytes, number] {\n  const u = schnorr.utils;\n  const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n  const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n  const Q = P.add(Point.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n  const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n  return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it's too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexport const TAPROOT_UNSPENDABLE_KEY: Bytes = sha256(Point.BASE.toRawBytes(false));\n\nexport type BTC_NETWORK = {\n  bech32: string;\n  pubKeyHash: number;\n  scriptHash: number;\n  wif: number;\n};\nexport const NETWORK: BTC_NETWORK = {\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\n\nexport const TEST_NETWORK: BTC_NETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n\n// Exported for tests, internal method\nexport function compareBytes(a: Bytes, b: Bytes): number {\n  if (!isBytes(a) || !isBytes(b)) throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n  // -1 -> a<b, 0 -> a==b, 1 -> a>b\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) if (a[i] != b[i]) return Math.sign(a[i] - b[i]);\n  return Math.sign(a.length - b.length);\n}\n", "import * as P from 'micro-packed';\nimport { isBytes } from './utils.ts';\n\nexport const MAX_SCRIPT_BYTE_LENGTH = 520;\n\n// prettier-ignore\nexport enum OP {\n  OP_0 = 0x00, PUSHDATA1 = 0x4c, PUSHDATA2, PUSHDATA4, '1NEGATE',\n  RESERVED = 0x50,\n  OP_1, OP_2, OP_3, OP_4, OP_5, OP_6, OP_7, OP_8,\n  OP_9, OP_10, OP_11, OP_12, OP_13, OP_14, OP_15, OP_16,\n  // Control\n  NOP, VER, IF, NOTIF, VERIF, VERNOTIF, ELSE, ENDIF, VERIFY, RETURN,\n  // Stack\n  TOALTSTACK, FROMALTSTACK, '2DROP', '2DUP', '3DUP', '2OVER', '2ROT', '2SWAP',\n  IFDUP, DEPTH, DROP, DUP, NIP, OVER, PICK, ROLL, ROT, SWAP, TUCK,\n  // Splice\n  CAT, SUBSTR, LEFT, RIGHT, SIZE,\n  // Boolean logic\n  INVERT, AND, OR, XOR, EQUAL, EQUALVERIFY, RESERVED1, RESERVED2,\n  // Numbers\n  '1ADD', '1SUB', '2MUL', '2DIV',\n  NEGATE, ABS, NOT, '0NOTEQUAL',\n  ADD, SUB, MUL, DIV, MOD, LSHIFT, RSHIFT, BOOLAND, BOOLOR,\n  NUMEQUAL, NUMEQUALVERIFY, NUMNOTEQUAL, LESSTHAN, GREATERTHAN,\n  LESSTHANOREQUAL, GREATERTHANOREQUAL, MIN, MAX, WITHIN,\n  // Crypto\n  RIPEMD160, SHA1, SHA256, HASH160, HASH256, CODESEPARATOR,\n  CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, CHECKMULTISIGVERIFY,\n  // Expansion\n  NOP1, CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY, NOP4, NOP5, NOP6, NOP7, NOP8, NOP9, NOP10,\n  // BIP 342\n  CHECKSIGADD,\n  // Invalid\n  INVALID = 0xff,\n}\n\nexport type ScriptOP = keyof typeof OP | Uint8Array | number;\nexport type ScriptType = ScriptOP[];\n\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can't know if buffer is a number or something else.\nexport function ScriptNum(bytesLimit = 6, forceMinimal = false): P.CoderType<bigint> {\n  return P.wrap({\n    encodeStream: (w: P.Writer, value: bigint) => {\n      if (value === 0n) return;\n      const neg = value < 0;\n      const val = BigInt(value);\n      const nums = [];\n      for (let abs = neg ? -val : val; abs; abs >>= 8n) nums.push(Number(abs & 0xffn));\n      if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);\n      else if (neg) nums[nums.length - 1] |= 0x80;\n      w.bytes(new Uint8Array(nums));\n    },\n    decodeStream: (r: P.Reader): bigint => {\n      const len = r.leftBytes;\n      if (len > bytesLimit)\n        throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n      if (len === 0) return 0n;\n      if (forceMinimal) {\n        const data = r.bytes(len, true);\n        // MSB is zero (without sign bit) -> not minimally encoded\n        if ((data[data.length - 1] & 0x7f) === 0) {\n          // exception\n          if (len <= 1 || (data[data.length - 2] & 0x80) === 0)\n            throw new Error('Non-minimally encoded ScriptNum');\n        }\n      }\n      let last = 0;\n      let res = 0n;\n      for (let i = 0; i < len; ++i) {\n        last = r.byte();\n        res |= BigInt(last) << (8n * BigInt(i));\n      }\n      if (last >= 0x80) {\n        res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n        res = -res;\n      }\n      return res;\n    },\n  });\n}\n\nexport function OpToNum(op: ScriptOP, bytesLimit = 4, forceMinimal = true): number | undefined {\n  if (typeof op === 'number') return op;\n  if (isBytes(op)) {\n    try {\n      const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n      if (val > Number.MAX_SAFE_INTEGER) return;\n      return Number(val);\n    } catch (e) {\n      return;\n    }\n  }\n  return;\n}\n\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexport const Script: P.CoderType<ScriptType> = P.wrap({\n  encodeStream: (w: P.Writer, value: ScriptType) => {\n    for (let o of value) {\n      if (typeof o === 'string') {\n        if (OP[o] === undefined) throw new Error(`Unknown opcode=${o}`);\n        w.byte(OP[o]);\n        continue;\n      } else if (typeof o === 'number') {\n        if (o === 0x00) {\n          w.byte(0x00);\n          continue;\n        } else if (1 <= o && o <= 16) {\n          w.byte(OP.OP_1 - 1 + o);\n          continue;\n        }\n      }\n      // Encode big numbers\n      if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));\n      if (!isBytes(o)) throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n      // Bytes\n      const len = o.length;\n      if (len < OP.PUSHDATA1) w.byte(len);\n      else if (len <= 0xff) {\n        w.byte(OP.PUSHDATA1);\n        w.byte(len);\n      } else if (len <= 0xffff) {\n        w.byte(OP.PUSHDATA2);\n        w.bytes(P.U16LE.encode(len));\n      } else {\n        w.byte(OP.PUSHDATA4);\n        w.bytes(P.U32LE.encode(len));\n      }\n      w.bytes(o);\n    }\n  },\n  decodeStream: (r: P.Reader): ScriptType => {\n    const out: ScriptType = [];\n    while (!r.isEnd()) {\n      const cur = r.byte();\n      // if 0 < cur < 78\n      if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n        let len;\n        if (cur < OP.PUSHDATA1) len = cur;\n        else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);\n        else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);\n        else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);\n        else throw new Error('Should be not possible');\n        out.push(r.bytes(len));\n      } else if (cur === 0x00) {\n        out.push(0);\n      } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n        out.push(cur - (OP.OP_1 - 1));\n      } else {\n        const op = OP[cur] as keyof typeof OP;\n        if (op === undefined) throw new Error(`Unknown opcode=${cur.toString(16)}`);\n        out.push(op);\n      }\n    }\n    return out;\n  },\n});\n\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits: Record<number, [number, number, bigint, bigint]> = {\n  0xfd: [0xfd, 2, 253n, 65535n],\n  0xfe: [0xfe, 4, 65536n, 4294967295n],\n  0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexport const CompactSize: P.CoderType<bigint> = P.wrap({\n  encodeStream: (w: P.Writer, value: bigint) => {\n    if (typeof value === 'number') value = BigInt(value);\n    if (0n <= value && value <= 252n) return w.byte(Number(value));\n    for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n      if (start > value || value > stop) continue;\n      w.byte(flag);\n      for (let i = 0; i < bytes; i++) w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n      return;\n    }\n    throw w.err(`VarInt too big: ${value}`);\n  },\n  decodeStream: (r: P.Reader): bigint => {\n    const b0 = r.byte();\n    if (b0 <= 0xfc) return BigInt(b0);\n    const [_, bytes, start] = CSLimits[b0];\n    let num = 0n;\n    for (let i = 0; i < bytes; i++) num |= BigInt(r.byte()) << (8n * BigInt(i));\n    if (num < start) throw r.err(`Wrong CompactSize(${8 * bytes})`);\n    return num;\n  },\n});\n\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nexport const CompactSizeLen: P.CoderType<number> = P.apply(CompactSize, P.coders.numberBigint);\n\n// ui8a of size <CompactSize>\nexport const VarBytes: P.CoderType<Uint8Array> = P.bytes(CompactSize);\n\n// SegWit v0 stack of witness buffers\nexport const RawWitness: P.CoderType<Uint8Array[]> = P.array(CompactSizeLen, VarBytes);\n\n// Array of size <CompactSize>\nexport const BTCArray = <T>(t: P.CoderType<T>): P.CoderType<T[]> => P.array(CompactSize, t);\n\nexport const RawInput = P.struct({\n  txid: P.bytes(32, true), // hash(prev_tx),\n  index: P.U32LE, // output number of previous tx\n  finalScriptSig: VarBytes, // btc merges input and output script, executes it. If ok = tx passes\n  sequence: P.U32LE, // ?\n});\n\nexport const RawOutput = P.struct({ amount: P.U64LE, script: VarBytes });\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n  version: P.I32LE,\n  segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  witnesses: P.flagged('segwitFlag', P.array('inputs/length', RawWitness)),\n  // < 500000000\tBlock number at which this transaction is unlocked\n  // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n  // Handled as part of PSBTv2\n  lockTime: P.U32LE,\n});\n\nfunction validateRawTx(tx: P.UnwrapCoder<typeof _RawTx>) {\n  if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n    throw new Error('Segwit flag with empty witnesses array');\n  return tx;\n}\nexport const RawTx: typeof _RawTx = P.validate(_RawTx, validateRawTx);\n// Pre-SegWit serialization format (for PSBTv0)\nexport const RawOldTx = P.struct({\n  version: P.I32LE,\n  inputs: BTCArray(RawInput),\n  outputs: BTCArray(RawOutput),\n  lockTime: P.U32LE,\n});\n", "import { hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport {\n  CompactSize,\n  CompactSizeLen,\n  RawOldTx,\n  RawOutput,\n  RawTx,\n  RawWitness,\n  VarBytes,\n} from './script.ts';\nimport { type Bytes, compareBytes, equalBytes, PubT, validatePubkey } from './utils.ts';\n\n// PSBT BIP174, BIP370, BIP371\n\n// Can be 33 or 64 bytes\nconst PubKeyECDSA: P.CoderType<Uint8Array> = P.validate(P.bytes(null), (pub) =>\n  validatePubkey(pub, PubT.ecdsa)\n);\nconst PubKeySchnorr: P.CoderType<Uint8Array> = P.validate(P.bytes(32), (pub) =>\n  validatePubkey(pub, PubT.schnorr)\n);\nconst SignatureSchnorr: P.CoderType<Uint8Array> = P.validate(P.bytes(null), (sig) => {\n  if (sig.length !== 64 && sig.length !== 65)\n    throw new Error('Schnorr signature should be 64 or 65 bytes long');\n  return sig;\n});\n\nconst BIP32Der = P.struct({\n  fingerprint: P.U32BE,\n  path: P.array(null, P.U32LE),\n});\nconst TaprootBIP32Der = P.struct({\n  hashes: P.array(CompactSizeLen, P.bytes(32)),\n  der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n  version: P.U8, // With parity :(\n  internalKey: P.bytes(32),\n  merklePath: P.array(null, P.bytes(32)),\n});\nexport const TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n  if (cb.merklePath.length > 128)\n    throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n  return cb;\n});\n\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(\n  null,\n  P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: VarBytes,\n  })\n);\n\nconst BytesInf: P.CoderType<P.Bytes> = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20: P.CoderType<P.Bytes> = P.bytes(20);\nconst Bytes32: P.CoderType<P.Bytes> = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nexport const PSBTGlobal = {\n  unsignedTx:       [0x00, false,      RawOldTx,          [0], [0],    false],\n  xpub:             [0x01, GlobalXPUB, BIP32Der,       [],  [0, 2], false],\n  txVersion:        [0x02, false,      P.U32LE,        [2], [2],    false],\n  fallbackLocktime: [0x03, false,      P.U32LE,        [],  [2],    false],\n  inputCount:       [0x04, false,      CompactSizeLen, [2], [2],    false],\n  outputCount:      [0x05, false,      CompactSizeLen, [2], [2],    false],\n  txModifiable:     [0x06, false,      P.U8,           [],  [2],    false],   // TODO: bitfield\n  version:          [0xfb, false,      P.U32LE,        [],  [0, 2], false],\n  proprietary:      [0xfc, BytesInf,   BytesInf,       [],  [0, 2], false],\n} as const;\n// prettier-ignore\nexport const PSBTInput = {\n  nonWitnessUtxo:         [0x00, false,               RawTx,            [],  [0, 2], false],\n  witnessUtxo:            [0x01, false,               RawOutput,        [],  [0, 2], false],\n  partialSig:             [0x02, PubKeyECDSA,         BytesInf,         [],  [0, 2], false],\n  sighashType:            [0x03, false,               P.U32LE,          [],  [0, 2], false],\n  redeemScript:           [0x04, false,               BytesInf,         [],  [0, 2], false],\n  witnessScript:          [0x05, false,               BytesInf,         [],  [0, 2], false],\n  bip32Derivation:        [0x06, PubKeyECDSA,         BIP32Der,         [],  [0, 2], false],\n  finalScriptSig:         [0x07, false,               BytesInf,         [],  [0, 2], false],\n  finalScriptWitness:     [0x08, false,               RawWitness,       [],  [0, 2], false],\n  porCommitment:          [0x09, false,               BytesInf,         [],  [0, 2], false],\n  ripemd160:              [0x0a, Bytes20,             BytesInf,         [],  [0, 2], false],\n  sha256:                 [0x0b, Bytes32,             BytesInf,         [],  [0, 2], false],\n  hash160:                [0x0c, Bytes20,             BytesInf,         [],  [0, 2], false],\n  hash256:                [0x0d, Bytes32,             BytesInf,         [],  [0, 2], false],\n  txid:                   [0x0e, false,               Bytes32,          [2], [2],    true],\n  index:                  [0x0f, false,               P.U32LE,          [2], [2],    true],\n  sequence:               [0x10, false,               P.U32LE,          [],  [2],    true],\n  requiredTimeLocktime:   [0x11, false,               P.U32LE,          [],  [2],    false],\n  requiredHeightLocktime: [0x12, false,               P.U32LE,          [],  [2],    false],\n  tapKeySig:              [0x13, false,               SignatureSchnorr, [],  [0, 2], false],\n  tapScriptSig:           [0x14, tapScriptSigKey,     SignatureSchnorr, [],  [0, 2], false],\n  tapLeafScript:          [0x15, TaprootControlBlock, BytesInf,         [],  [0, 2], false],\n  tapBip32Derivation:     [0x16, Bytes32,             TaprootBIP32Der,  [],  [0, 2], false],\n  tapInternalKey:         [0x17, false,               PubKeySchnorr,    [],  [0, 2], false],\n  tapMerkleRoot:          [0x18, false,               Bytes32,          [],  [0, 2], false],\n  proprietary:            [0xfc, BytesInf,            BytesInf,         [],  [0, 2], false],\n} as const;\n// All other keys removed when finalizing\nexport const PSBTInputFinalKeys: (keyof TransactionInput)[] = [\n  'txid',\n  'sequence',\n  'index',\n  'witnessUtxo',\n  'nonWitnessUtxo',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'unknown',\n];\n\n// Can be modified even on signed input\nexport const PSBTInputUnsignedKeys: (keyof TransactionInput)[] = [\n  'partialSig',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'tapKeySig',\n  'tapScriptSig',\n];\n\n// prettier-ignore\nexport const PSBTOutput = {\n  redeemScript:       [0x00, false,         BytesInf,        [],  [0, 2], false],\n  witnessScript:      [0x01, false,         BytesInf,        [],  [0, 2], false],\n  bip32Derivation:    [0x02, PubKeyECDSA,   BIP32Der,        [],  [0, 2], false],\n  amount:             [0x03, false,         P.I64LE,         [2], [2],    true],\n  script:             [0x04, false,         BytesInf,        [2], [2],    true],\n  tapInternalKey:     [0x05, false,         PubKeySchnorr,   [],  [0, 2], false],\n  tapTree:            [0x06, false,         tapTree,         [],  [0, 2], false],\n  tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [],  [0, 2], false],\n  proprietary:        [0xfc, BytesInf,      BytesInf,        [],  [0, 2], false],\n} as const;\n\n// Can be modified even on signed input\nexport const PSBTOutputUnsignedKeys: (keyof typeof PSBTOutput)[] = [];\n\nconst PSBTKeyPair = P.array(\n  P.NULL,\n  P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(CompactSizeLen, P.struct({ type: CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(CompactSizeLen),\n  })\n);\n\ntype PSBTKeyCoder = P.CoderType<any> | false;\n\ntype PSBTKeyMapInfo = Readonly<\n  [\n    number,\n    PSBTKeyCoder,\n    any,\n    readonly number[], // versionsRequiringInclusion\n    readonly number[], // versionsAllowsInclusion\n    boolean, // silentIgnore\n  ]\n>;\n\nfunction PSBTKeyInfo(info: PSBTKeyMapInfo) {\n  const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n  return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\n\ntype PSBTKeyMap = Record<string, PSBTKeyMapInfo>;\n\nconst PSBTUnknownKey: P.CoderType<\n  P.StructInput<{\n    type: number;\n    key: Uint8Array;\n  }>\n> = P.struct({ type: CompactSizeLen, key: P.bytes(null) });\ntype PSBTUnknownFields = { unknown?: [P.UnwrapCoder<typeof PSBTUnknownKey>, Bytes][] };\nexport type PSBTKeyMapKeys<T extends PSBTKeyMap> = {\n  -readonly [K in keyof T]?: T[K][1] extends false\n    ? P.UnwrapCoder<T[K][2]>\n    : [P.UnwrapCoder<T[K][1]>, P.UnwrapCoder<T[K][2]>][];\n} & PSBTUnknownFields;\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap<T extends PSBTKeyMap>(psbtEnum: T): P.CoderType<PSBTKeyMapKeys<T>> {\n  // -> Record<type, [keyName, ...coders]>\n  const byType: Record<number, [string, PSBTKeyCoder, P.CoderType<any>]> = {};\n  for (const k in psbtEnum) {\n    const [num, kc, vc] = psbtEnum[k];\n    byType[num] = [k, kc, vc];\n  }\n  return P.wrap({\n    encodeStream: (w: P.Writer, value: PSBTKeyMapKeys<T>) => {\n      let out: P.UnwrapCoder<typeof PSBTKeyPair> = [];\n      // Because we use order of psbtEnum, keymap is sorted here\n      for (const name in psbtEnum) {\n        const val = value[name];\n        if (val === undefined) continue;\n        const [type, kc, vc] = psbtEnum[name];\n        if (!kc) {\n          out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n        } else {\n          // Low level interface, returns keys as is (with duplicates). Useful for debug\n          const kv: [Bytes, Bytes][] = val!.map(\n            ([k, v]: [P.UnwrapCoder<typeof kc>, P.UnwrapCoder<typeof vc>]) => [\n              kc.encode(k),\n              vc.encode(v),\n            ]\n          );\n          // sort by keys\n          kv.sort((a, b) => compareBytes(a[0], b[0]));\n          for (const [key, value] of kv) out.push({ key: { key, type }, value });\n        }\n      }\n      if (value.unknown) {\n        value.unknown.sort((a, b) => compareBytes(a[0].key, b[0].key));\n        for (const [k, v] of value.unknown) out.push({ key: k, value: v });\n      }\n      PSBTKeyPair.encodeStream(w, out);\n    },\n    decodeStream: (r: P.Reader): PSBTKeyMapKeys<T> => {\n      const raw = PSBTKeyPair.decodeStream(r);\n      const out: any = {};\n      const noKey: Record<string, true> = {};\n      for (const elm of raw) {\n        let name = 'unknown';\n        let key: any = elm.key.key;\n        let value = elm.value;\n        if (byType[elm.key.type]) {\n          const [_name, kc, vc] = byType[elm.key.type];\n          name = _name;\n          if (!kc && key.length) {\n            throw new Error(\n              `PSBT: Non-empty key for ${name} (key=${hex.encode(key)} value=${hex.encode(value)}`\n            );\n          }\n          key = kc ? kc.decode(key) : undefined;\n          value = vc.decode(value);\n          if (!kc) {\n            if (out[name]) throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n            out[name] = value;\n            noKey[name] = true;\n            continue;\n          }\n        } else {\n          // For unknown: add key type inside key\n          key = { type: elm.key.type, key: elm.key.key };\n        }\n        // Only keyed elements at this point\n        if (noKey[name])\n          throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n        if (!out[name]) out[name] = [];\n        out[name].push([key, value]);\n      }\n      return out;\n    },\n  });\n}\n\nexport const PSBTInputCoder = P.validate(PSBTKeyMap(PSBTInput), (i) => {\n  if (i.finalScriptWitness && !i.finalScriptWitness.length)\n    throw new Error('validateInput: empty finalScriptWitness');\n  //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n  if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');\n  if (i.partialSig) for (const [k] of i.partialSig) validatePubkey(k, PubT.ecdsa);\n  if (i.bip32Derivation) for (const [k] of i.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n  if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n    throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n  // unsigned little endian integer greater than 0 and less than 500000000\n  if (\n    i.requiredHeightLocktime !== undefined &&\n    (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)\n  )\n    throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n  if (i.tapLeafScript) {\n    // tap leaf version appears here twice: in control block and at the end of script\n    for (const [k, v] of i.tapLeafScript) {\n      if ((k.version & 0b1111_1110) !== v[v.length - 1])\n        throw new Error('validateInput: tapLeafScript version mimatch');\n      if (v[v.length - 1] & 1)\n        throw new Error('validateInput: tapLeafScript version has parity bit!');\n    }\n  }\n  return i;\n});\n\nexport type ExtendType<T, E> = {\n  [K in keyof T]: K extends keyof E ? E[K] | T[K] : T[K];\n};\nexport type RequireType<T, K extends keyof T> = T & {\n  [P in K]-?: T[P];\n};\n\nexport type TransactionInput = P.UnwrapCoder<typeof PSBTInputCoder>;\nexport type TransactionInputUpdate = ExtendType<\n  TransactionInput,\n  {\n    nonWitnessUtxo?: string | Bytes;\n    txid?: string;\n  }\n>;\n\nexport const PSBTOutputCoder = P.validate(PSBTKeyMap(PSBTOutput), (o) => {\n  if (o.bip32Derivation) for (const [k] of o.bip32Derivation) validatePubkey(k, PubT.ecdsa);\n  return o;\n});\n\nexport type TransactionOutput = P.UnwrapCoder<typeof PSBTOutputCoder>;\nexport type TransactionOutputUpdate = ExtendType<TransactionOutput, { script?: string }>;\nexport type TransactionOutputRequired = {\n  script: Bytes;\n  amount: bigint;\n};\n\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(PSBTGlobal), (g) => {\n  const version = g.version || 0;\n  if (version === 0) {\n    if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');\n    for (const inp of g.unsignedTx.inputs)\n      if (inp.finalScriptSig && inp.finalScriptSig.length)\n        throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n  }\n  return g;\n});\n\nexport const _RawPSBTV0 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/unsignedTx/inputs/length', PSBTInputCoder),\n  outputs: P.array(null, PSBTOutputCoder),\n});\n\nexport const _RawPSBTV2 = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  global: PSBTGlobalCoder,\n  inputs: P.array('global/inputCount', PSBTInputCoder),\n  outputs: P.array('global/outputCount', PSBTOutputCoder),\n});\n\nexport type PSBTRaw = typeof _RawPSBTV0 | typeof _RawPSBTV2;\n\nexport const _DebugPSBT = P.struct({\n  magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n  items: P.array(\n    null,\n    P.apply(\n      P.array(P.NULL, P.tuple([P.hex(CompactSizeLen), P.bytes(CompactSize)])),\n      P.coders.dict()\n    )\n  ),\n});\n\nfunction validatePSBTFields<T extends PSBTKeyMap>(\n  version: number,\n  info: T,\n  lst: PSBTKeyMapKeys<T>\n) {\n  for (const k in lst) {\n    if (k === 'unknown') continue;\n    if (!info[k]) continue;\n    const { allowInc } = PSBTKeyInfo(info[k]);\n    if (!allowInc.includes(version)) throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n  }\n  for (const k in info) {\n    const { reqInc } = PSBTKeyInfo(info[k]);\n    if (reqInc.includes(version) && lst[k] === undefined)\n      throw new Error(`PSBTv${version}: missing required field ${k}`);\n  }\n}\n\nexport function cleanPSBTFields<T extends PSBTKeyMap>(\n  version: number,\n  info: T,\n  lst: PSBTKeyMapKeys<T>\n): PSBTKeyMapKeys<T> {\n  const out: PSBTKeyMapKeys<T> = {};\n  for (const _k in lst) {\n    const k = _k as string & keyof PSBTKeyMapKeys<T>;\n    if (k !== 'unknown') {\n      if (!info[k]) continue;\n      const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n      if (!allowInc.includes(version)) {\n        if (silentIgnore) continue;\n        throw new Error(\n          `Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`\n        );\n      }\n    }\n    out[k] = lst[k];\n  }\n  return out;\n}\n\nfunction validatePSBT(tx: P.UnwrapCoder<PSBTRaw>) {\n  const version = (tx && tx.global && tx.global.version) || 0;\n  validatePSBTFields(version, PSBTGlobal, tx.global);\n  for (const i of tx.inputs) validatePSBTFields(version, PSBTInput, i);\n  for (const o of tx.outputs) validatePSBTFields(version, PSBTOutput, o);\n  // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n  const inputCount = !version ? tx.global.unsignedTx!.inputs.length : tx.global.inputCount!;\n  if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');\n  const inputsLeft = tx.inputs.slice(inputCount);\n  if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n    throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n  // Same for inputs\n  const outputCount = !version ? tx.global.unsignedTx!.outputs.length : tx.global.outputCount!;\n  if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');\n  const outputsLeft = tx.outputs.slice(outputCount);\n  if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n    throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n  return tx;\n}\n\nexport function mergeKeyMap<T extends PSBTKeyMap>(\n  psbtEnum: T,\n  val: PSBTKeyMapKeys<T>,\n  cur?: PSBTKeyMapKeys<T>,\n  allowedFields?: (keyof PSBTKeyMapKeys<T>)[],\n  allowUnknown?: boolean\n): PSBTKeyMapKeys<T> {\n  const res: PSBTKeyMapKeys<T> = { ...cur, ...val };\n  // All arguments can be provided as hex\n  for (const k in psbtEnum) {\n    const key = k as keyof typeof psbtEnum;\n    const [_, kC, vC] = psbtEnum[key];\n    type _KV = [P.UnwrapCoder<typeof kC>, P.UnwrapCoder<typeof vC>];\n    const cannotChange = allowedFields && !allowedFields.includes(k);\n    if (val[k] === undefined && k in val) {\n      if (cannotChange) throw new Error(`Cannot remove signed field=${k}`);\n      delete res[k];\n    } else if (kC) {\n      const oldKV = (cur && cur[k] ? cur[k] : []) as _KV[];\n      let newKV = val[key] as _KV[];\n      if (newKV) {\n        if (!Array.isArray(newKV)) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n        // Decode hex in k-v\n        newKV = newKV.map((val: _KV): _KV => {\n          if (val.length !== 2) throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n          return [\n            typeof val[0] === 'string' ? kC.decode(hex.decode(val[0])) : val[0],\n            typeof val[1] === 'string' ? vC.decode(hex.decode(val[1])) : val[1],\n          ];\n        });\n        const map: Record<string, _KV> = {};\n        const add = (kStr: string, k: _KV[0], v: _KV[1]) => {\n          if (map[kStr] === undefined) {\n            map[kStr] = [k, v];\n            return;\n          }\n          const oldVal = hex.encode(vC.encode(map[kStr][1]));\n          const newVal = hex.encode(vC.encode(v));\n          if (oldVal !== newVal)\n            throw new Error(\n              `keyMap(${key as string}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`\n            );\n        };\n        for (const [k, v] of oldKV) {\n          const kStr = hex.encode(kC.encode(k));\n          add(kStr, k, v);\n        }\n        for (const [k, v] of newKV) {\n          const kStr = hex.encode(kC.encode(k));\n          // undefined removes previous value\n          if (v === undefined) {\n            if (cannotChange) throw new Error(`Cannot remove signed field=${key as string}/${k}`);\n            delete map[kStr];\n          } else add(kStr, k, v);\n        }\n        (res as any)[key] = Object.values(map) as _KV[];\n      }\n    } else if (typeof res[k] === 'string') {\n      res[k] = vC.decode(hex.decode(res[k] as string));\n    } else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n      if (!equalBytes(vC.encode(val[k]), vC.encode(cur[k])))\n        throw new Error(`Cannot change signed field=${k}`);\n    }\n  }\n  // Remove unknown keys except the \"unknown\" array if allowUnknown is true\n  for (const k in res) {\n    if (!psbtEnum[k]) {\n      if (allowUnknown && k === 'unknown') continue;\n      delete res[k];\n    }\n  }\n  return res;\n}\n\nexport const RawPSBTV0 = P.validate(_RawPSBTV0, validatePSBT);\nexport const RawPSBTV2 = P.validate(_RawPSBTV2, validatePSBT);\n", "import { bech32, bech32m, type Coder, createBase58check, hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport { TaprootControlBlock, type TransactionInput } from './psbt.ts';\nimport { OpToNum, Script, type ScriptType, VarBytes } from './script.ts';\nimport * as u from './utils.ts';\nimport { type BTC_NETWORK, type Bytes, NETWORK } from './utils.ts';\n\n// We need following items:\n// - encode/decode output script\n// - generate input script\n// - generate address/output/redeem from user input\n// P2ret represents generic interface for all p2* methods\nexport type P2Ret = {\n  type: string;\n  script: Bytes;\n  address?: string;\n  redeemScript?: Bytes;\n  witnessScript?: Bytes;\n  hash?: Bytes;\n};\n\n// Pay to Anchor (P2A)\ntype OutP2AType = { type: 'p2a'; script: Bytes };\nconst OutP2A: Coder<OptScript, OutP2AType | undefined> = {\n  encode(from: ScriptType): OutP2AType | undefined {\n    if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1]) || hex.encode(from[1]) !== '4e73')\n      return;\n    return { type: 'p2a', script: Script.encode(from) };\n  },\n  decode: (to: OutP2AType): OptScript => {\n    if (to.type !== 'p2a') return;\n    return [1, hex.decode('4e73')];\n  },\n};\n\n// Public Key (P2PK)\ntype OutPKType = { type: 'pk'; pubkey: Bytes };\nexport type OptScript = ScriptType | undefined;\n\nfunction isValidPubkey(pub: Bytes, type: u.PubT): boolean {\n  try {\n    u.validatePubkey(pub, type);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst OutPK: Coder<OptScript, OutPKType | undefined> = {\n  encode(from: ScriptType): OutPKType | undefined {\n    if (\n      from.length !== 2 ||\n      !u.isBytes(from[0]) ||\n      !isValidPubkey(from[0], u.PubT.ecdsa) ||\n      from[1] !== 'CHECKSIG'\n    )\n      return;\n    return { type: 'pk', pubkey: from[0] };\n  },\n  decode: (to: OutPKType): OptScript => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\n\n// Public Key Hash (P2PKH)\ntype OutPKHType = { type: 'pkh'; hash: Bytes };\nconst OutPKH: Coder<OptScript, OutPKHType | undefined> = {\n  encode(from: ScriptType): OutPKHType | undefined {\n    if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !u.isBytes(from[2]))\n      return;\n    if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;\n    return { type: 'pkh', hash: from[2] };\n  },\n  decode: (to: OutPKHType): OptScript =>\n    to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\n// Script Hash (P2SH)\ntype OutSHType = { type: 'sh'; hash: Bytes };\nconst OutSH: Coder<OptScript, OutSHType | undefined> = {\n  encode(from: ScriptType): OutSHType | undefined {\n    if (from.length !== 3 || from[0] !== 'HASH160' || !u.isBytes(from[1]) || from[2] !== 'EQUAL')\n      return;\n    return { type: 'sh', hash: from[1] };\n  },\n  decode: (to: OutSHType): OptScript =>\n    to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\n\n// Witness Script Hash (P2WSH)\ntype OutWSHType = { type: 'wsh'; hash: Bytes };\nconst OutWSH: Coder<OptScript, OutWSHType | undefined> = {\n  encode(from: ScriptType): OutWSHType | undefined {\n    if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1])) return;\n    if (from[1].length !== 32) return;\n    return { type: 'wsh', hash: from[1] };\n  },\n  decode: (to: OutWSHType): OptScript => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\n\n// Witness Public Key Hash (P2WPKH)\ntype OutWPKHType = { type: 'wpkh'; hash: Bytes };\nconst OutWPKH: Coder<OptScript, OutWPKHType | undefined> = {\n  encode(from: ScriptType): OutWPKHType | undefined {\n    if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1])) return;\n    if (from[1].length !== 20) return;\n    return { type: 'wpkh', hash: from[1] };\n  },\n  decode: (to: OutWPKHType): OptScript => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\n\n// Multisig (P2MS)\ntype OutMSType = { type: 'ms'; pubkeys: Bytes[]; m: number };\nconst OutMS: Coder<OptScript, OutMSType | undefined> = {\n  encode(from: ScriptType): OutMSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKMULTISIG') return;\n    const m = from[0];\n    const n = from[last - 1];\n    if (typeof m !== 'number' || typeof n !== 'number') return;\n    const pubkeys = from.slice(1, -2);\n    if (n !== pubkeys.length) return;\n    for (const pub of pubkeys) if (!u.isBytes(pub)) return;\n    return { type: 'ms', m, pubkeys: pubkeys as Bytes[] }; // we don't need n, since it is the same as pubkeys\n  },\n  // checkmultisig(n, ..pubkeys, m)\n  decode: (to: OutMSType): OptScript =>\n    to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\n// Taproot (P2TR)\ntype OutTRType = { type: 'tr'; pubkey: Bytes };\nconst OutTR: Coder<OptScript, OutTRType | undefined> = {\n  encode(from: ScriptType): OutTRType | undefined {\n    if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1])) return;\n    return { type: 'tr', pubkey: from[1] };\n  },\n  decode: (to: OutTRType): OptScript => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\n\n// Taproot N-of-N multisig (P2TR_NS)\ntype OutTRNSType = { type: 'tr_ns'; pubkeys: Bytes[] };\nconst OutTRNS: Coder<OptScript, OutTRNSType | undefined> = {\n  encode(from: ScriptType): OutTRNSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    // On error return, since it can be different script\n    for (let i = 0; i < last; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;\n        continue;\n      }\n      if (!u.isBytes(elm)) return;\n      pubkeys.push(elm);\n    }\n    return { type: 'tr_ns', pubkeys };\n  },\n  decode: (to: OutTRNSType): OptScript => {\n    if (to.type !== 'tr_ns') return;\n    const out: ScriptType = [];\n    for (let i = 0; i < to.pubkeys.length - 1; i++) out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n    out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n    return out;\n  },\n};\n\n// Taproot M-of-N Multisig (P2TR_MS)\ntype OutTRMSType = { type: 'tr_ms'; pubkeys: Bytes[]; m: number };\nconst OutTRMS: Coder<OptScript, OutTRMSType | undefined> = {\n  encode(from: ScriptType): OutTRMSType | undefined {\n    const last = from.length - 1;\n    if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;\n    const pubkeys = [];\n    const m = OpToNum(from[last - 1]);\n    if (typeof m !== 'number') return;\n    for (let i = 0; i < last - 1; i++) {\n      const elm = from[i];\n      if (i & 1) {\n        if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n          throw new Error('OutScript.encode/tr_ms: wrong element');\n        continue;\n      }\n      if (!u.isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');\n      pubkeys.push(elm);\n    }\n    return { type: 'tr_ms', pubkeys, m };\n  },\n  decode: (to: OutTRMSType): OptScript => {\n    if (to.type !== 'tr_ms') return;\n    const out: ScriptType = [to.pubkeys[0], 'CHECKSIG'];\n    for (let i = 1; i < to.pubkeys.length; i++) out.push(to.pubkeys[i], 'CHECKSIGADD');\n    out.push(to.m, 'NUMEQUAL');\n    return out;\n  },\n};\n\n// Unknown output type\ntype OutUnknownType = { type: 'unknown'; script: Bytes };\nconst OutUnknown: Coder<OptScript, OutUnknownType | undefined> = {\n  encode(from: ScriptType): OutUnknownType | undefined {\n    return { type: 'unknown', script: Script.encode(from) };\n  },\n  decode: (to: OutUnknownType): OptScript =>\n    to.type === 'unknown' ? Script.decode(to.script) : undefined,\n};\n// /Payments\n\nconst OutScripts = [\n  OutP2A,\n  OutPK,\n  OutPKH,\n  OutSH,\n  OutWSH,\n  OutWPKH,\n  OutMS,\n  OutTR,\n  OutTRNS,\n  OutTRMS,\n  OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(Script, P.coders.match(OutScripts));\n\n/*\n * UNSAFE: Custom scripts: mostly ordinals, be very careful when crafting new scripts\n * Only taproot supported for now.\n * NOTE: we can use same to move finalization logic from Transaction, but it will significantly change audited code.\n */\n\ntype FinalizeSignature = [{ pubKey: Bytes; leafHash: Bytes }, Bytes];\ntype CustomScriptOut = { type: string } & Record<string, any>;\nexport type CustomScript = Coder<OptScript, CustomScriptOut | undefined> & {\n  finalizeTaproot?: (\n    script: Bytes,\n    parsed: CustomScriptOut,\n    signatures: FinalizeSignature[]\n  ) => Bytes[] | undefined;\n};\n\n// We can validate this once, because of packed & coders\nexport const OutScript: P.CoderType<\n  NonNullable<\n    | OutP2AType\n    | OutPKType\n    | OutPKHType\n    | OutSHType\n    | OutWSHType\n    | OutWPKHType\n    | OutMSType\n    | OutTRType\n    | OutTRNSType\n    | OutTRMSType\n    | OutUnknownType\n    | undefined\n  >\n> = P.validate(_OutScript, (i) => {\n  if (i.type === 'pk' && !isValidPubkey(i.pubkey, u.PubT.ecdsa))\n    throw new Error('OutScript/pk: wrong key');\n  if (\n    (i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n    (!u.isBytes(i.hash) || i.hash.length !== 20)\n  )\n    throw new Error(`OutScript/${i.type}: wrong hash`);\n  if (i.type === 'wsh' && (!u.isBytes(i.hash) || i.hash.length !== 32))\n    throw new Error(`OutScript/wsh: wrong hash`);\n  if (i.type === 'tr' && (!u.isBytes(i.pubkey) || !isValidPubkey(i.pubkey, u.PubT.schnorr)))\n    throw new Error('OutScript/tr: wrong taproot public key');\n  if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n    if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');\n  if (i.type === 'ms') {\n    const n = i.pubkeys.length;\n    for (const p of i.pubkeys)\n      if (!isValidPubkey(p, u.PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');\n    if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');\n  }\n  if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n    for (const p of i.pubkeys)\n      if (!isValidPubkey(p, u.PubT.schnorr)) throw new Error(`OutScript/${i.type}: wrong pubkey`);\n  }\n  if (i.type === 'tr_ms') {\n    const n = i.pubkeys.length;\n    if (i.m <= 0 || n > 999 || i.m > n) throw new Error('OutScript/tr_ms: invalid params');\n  }\n  return i;\n});\nexport type OutScriptType = typeof OutScript;\n\n// Basic sanity check for scripts\nfunction checkWSH(s: OutWSHType, witnessScript: Bytes) {\n  if (!u.equalBytes(s.hash, u.sha256(witnessScript)))\n    throw new Error('checkScript: wsh wrong witnessScript hash');\n  const w = OutScript.decode(witnessScript);\n  if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n    throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n  if (w.type === 'wpkh' || w.type === 'sh')\n    throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\n\nexport function checkScript(script?: Bytes, redeemScript?: Bytes, witnessScript?: Bytes): void {\n  if (script) {\n    const s = OutScript.decode(script);\n    // ms||pk maybe work, but there will be no address, hard to spend\n    if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n      throw new Error(`checkScript: non-wrapped ${s.type}`);\n    if (s.type === 'sh' && redeemScript) {\n      if (!u.equalBytes(s.hash, u.hash160(redeemScript)))\n        throw new Error('checkScript: sh wrong redeemScript hash');\n      const r = OutScript.decode(redeemScript);\n      if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n        throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n      // Not sure if this unspendable, but we cannot represent this via PSBT\n      if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n    }\n    if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);\n  }\n  if (redeemScript) {\n    const r = OutScript.decode(redeemScript);\n    if (r.type === 'wsh' && witnessScript) checkWSH(r, witnessScript);\n  }\n}\n\nfunction uniqPubkey(pubkeys: Bytes[]) {\n  const map: Record<string, boolean> = {};\n  for (const pub of pubkeys) {\n    const key = hex.encode(pub);\n    if (map[key]) throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(hex.encode)}`);\n    map[key] = true;\n  }\n}\n// We want narrow types inside p2* methods, but always want to type-check if they compatible with P2Ret here!\n// Also we use satisfies for additional check (ts 4.9+)\ntype Extends<T, U> = T extends U ? T : never;\n\nexport type P2PK = { type: 'pk'; script: Bytes };\nexport const p2pk = (pubkey: Bytes, _network: BTC_NETWORK = NETWORK): Extends<P2PK, P2Ret> => {\n  // network is unused\n  if (!isValidPubkey(pubkey, u.PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');\n  return { type: 'pk', script: OutScript.encode({ type: 'pk', pubkey }) } as const satisfies P2Ret;\n};\n\nexport type P2PKH = { type: 'pkh'; script: Bytes; address: string; hash: Bytes };\nexport const p2pkh = (publicKey: Bytes, network: BTC_NETWORK = NETWORK): Extends<P2PKH, P2Ret> => {\n  if (!isValidPubkey(publicKey, u.PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');\n  const hash = u.hash160(publicKey);\n  return {\n    type: 'pkh',\n    script: OutScript.encode({ type: 'pkh', hash }),\n    address: Address(network).encode({ type: 'pkh', hash }),\n    hash,\n  } as const satisfies P2Ret;\n};\n\nexport type P2SHBase = {\n  type: 'sh';\n  redeemScript: Bytes;\n  script: Bytes;\n  address: string;\n  hash: Bytes;\n};\nexport type P2SHWithWitness = P2SHBase & { witnessScript: Bytes };\nexport type P2SHWithoutWitness = Omit<P2SHBase, 'witnessScript'>;\nexport type P2SHReturn<T extends P2Ret> = T extends { witnessScript: Bytes }\n  ? P2SHWithWitness\n  : P2SHWithoutWitness;\nexport const p2sh = <T extends P2Ret>(\n  child: T,\n  network: BTC_NETWORK = NETWORK\n): Extends<P2SHReturn<T>, P2Ret> => {\n  // It is already tested inside noble-hashes and checkScript\n  const cs = child.script;\n  if (!u.isBytes(cs)) throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n  const hash = u.hash160(cs);\n  const script = OutScript.encode({ type: 'sh', hash });\n  checkScript(script, cs, child.witnessScript);\n  if (child.witnessScript) {\n    return {\n      type: 'sh',\n      redeemScript: cs,\n      script: OutScript.encode({ type: 'sh', hash }),\n      address: Address(network).encode({ type: 'sh', hash }),\n      hash,\n      witnessScript: child.witnessScript,\n    } as Extends<P2SHReturn<T>, P2Ret> satisfies P2Ret;\n  } else {\n    return {\n      type: 'sh',\n      redeemScript: cs,\n      script: OutScript.encode({ type: 'sh', hash }),\n      address: Address(network).encode({ type: 'sh', hash }),\n      hash,\n    } as Extends<P2SHReturn<T>, P2Ret> satisfies P2Ret;\n  }\n};\n\nexport type P2WSH = {\n  type: 'wsh';\n  witnessScript: Bytes;\n  script: Bytes;\n  address: string;\n  hash: Bytes;\n};\nexport const p2wsh = (child: P2Ret, network: BTC_NETWORK = NETWORK): Extends<P2WSH, P2Ret> => {\n  const cs = child.script;\n  if (!u.isBytes(cs)) throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n  const hash = u.sha256(cs);\n  const script = OutScript.encode({ type: 'wsh', hash });\n  checkScript(script, undefined, cs);\n  return {\n    type: 'wsh',\n    witnessScript: cs,\n    script: OutScript.encode({ type: 'wsh', hash }),\n    address: Address(network).encode({ type: 'wsh', hash }),\n    hash,\n  } as const satisfies P2Ret;\n};\n\nexport type P2WPKH = { type: 'wpkh'; script: Bytes; address: string; hash: Bytes };\nexport const p2wpkh = (\n  publicKey: Bytes,\n  network: BTC_NETWORK = NETWORK\n): Extends<P2WPKH, P2Ret> => {\n  if (!isValidPubkey(publicKey, u.PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');\n  if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');\n  const hash = u.hash160(publicKey);\n  return {\n    type: 'wpkh',\n    script: OutScript.encode({ type: 'wpkh', hash }),\n    address: Address(network).encode({ type: 'wpkh', hash }),\n    hash,\n  } as const satisfies P2Ret;\n};\n\nexport type P2MS = { type: 'ms'; script: Bytes };\nexport const p2ms = (\n  m: number,\n  pubkeys: Bytes[],\n  allowSamePubkeys = false\n): Extends<P2MS, P2Ret> => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'ms',\n    script: OutScript.encode({ type: 'ms', pubkeys, m }),\n  } as const satisfies P2Ret;\n};\n\nexport type HashedTree =\n  | { type: 'leaf'; version?: number; script: Bytes; hash: Bytes }\n  | { type: 'branch'; left: HashedTree; right: HashedTree; hash: Bytes };\nfunction checkTaprootScript(\n  script: Bytes,\n  internalPubKey: Bytes,\n  allowUnknownOutputs = false,\n  customScripts?: CustomScript[]\n) {\n  const out = OutScript.decode(script);\n  if (out.type === 'unknown') {\n    // NOTE: this check should be before allowUnknownOutputs, otherwise it will\n    // disable custom. All custom scripts for taproot should have prefix 'tr_'\n    if (customScripts) {\n      const cs = P.apply(Script, P.coders.match(customScripts));\n      const c = cs.decode(script);\n      if (c !== undefined) {\n        if (typeof c.type !== 'string' || !c.type.startsWith('tr_'))\n          throw new Error(`P2TR: invalid custom type=${c.type}`);\n        return;\n      }\n    }\n    if (allowUnknownOutputs) return;\n  }\n  if (!['tr_ns', 'tr_ms'].includes(out.type))\n    throw new Error(`P2TR: invalid leaf script=${out.type}`);\n  const outms = out as OutTRNSType | OutTRMSType;\n  if (!allowUnknownOutputs && outms.pubkeys) {\n    for (const p of outms.pubkeys) {\n      if (u.equalBytes(p, u.TAPROOT_UNSPENDABLE_KEY))\n        throw new Error('Unspendable taproot key in leaf script');\n      // It's likely a mistake at this point:\n      // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n      // but will take more space and fees.\n      // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n      // User creates 2 of 3 multisig of keys [A, B, C],\n      // but key A always can spend whole output without signatures from other keys.\n      // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n      if (u.equalBytes(p, internalPubKey)) {\n        throw new Error(\n          'Using P2TR with leaf script with same key as internal key is not supported'\n        );\n      }\n    }\n  }\n}\n\nexport type P2TR = {\n  type: 'tr';\n  script: Bytes;\n  address: string;\n  tweakedPubkey: Bytes;\n  tapInternalKey: Bytes;\n};\nexport type P2TR_TREE = P2TR & {\n  tapMerkleRoot: Bytes;\n  tapLeafScript: TransactionInput['tapLeafScript'];\n  leaves: TaprootLeaf[];\n};\n\nexport type TaprootNode = {\n  script: Bytes | string;\n  leafVersion?: number;\n  weight?: number;\n} & Partial<P2TR_TREE>;\nexport type TaprootScriptTree = TaprootNode | TaprootScriptTree[];\nexport type TaprootScriptList = TaprootNode[];\ntype _TaprootTreeInternal = {\n  weight?: number;\n  childs?: [_TaprootTreeInternal[], _TaprootTreeInternal[]];\n};\n\n// Helper for generating binary tree from list, with weights\nexport function taprootListToTree(taprootList: TaprootScriptList): TaprootScriptTree {\n  // Clone input in order to not corrupt it\n  const lst = Array.from(taprootList) as _TaprootTreeInternal[];\n  // We have at least 2 elements => can create branch\n  while (lst.length >= 2) {\n    // Sort: elements with smallest weight are in the end of queue\n    lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n    const b = lst.pop()!;\n    const a = lst.pop()!;\n    const weight = (a?.weight || 1) + (b?.weight || 1);\n    lst.push({\n      weight,\n      // Unwrap children array\n      // TODO: Very hard to remove any here\n      childs: [a?.childs || (a as any[]), b?.childs || (b as any)],\n    });\n  }\n  // At this point there is always 1 element in lst\n  const last = lst[0];\n  return (last?.childs || last) as TaprootScriptTree;\n}\n\nexport type TaprootLeaf = {\n  type: 'leaf';\n  version?: number;\n  script: Bytes;\n  hash: Bytes;\n  path: Bytes[];\n};\n\nexport type HashedTreeWithPath =\n  | TaprootLeaf\n  | {\n      type: 'branch';\n      left: HashedTreeWithPath;\n      right: HashedTreeWithPath;\n      hash: Bytes;\n      path: Bytes[];\n    };\n\nfunction taprootAddPath(tree: HashedTree, path: Bytes[] = []): HashedTreeWithPath {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return { ...tree, path };\n  if (tree.type !== 'branch') throw new Error(`taprootAddPath: wrong type=${tree}`);\n  return {\n    ...tree,\n    path,\n    // Left element has right hash in path and otherwise\n    left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n    right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n  };\n}\nfunction taprootWalkTree(tree: HashedTreeWithPath): TaprootLeaf[] {\n  if (!tree) throw new Error(`taprootAddPath: empty tree`);\n  if (tree.type === 'leaf') return [tree];\n  if (tree.type !== 'branch') throw new Error(`taprootWalkTree: wrong type=${tree}`);\n  return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\n\nfunction taprootHashTree(\n  tree: TaprootScriptTree,\n  internalPubKey: Bytes,\n  allowUnknownOutputs = false,\n  customScripts?: CustomScript[]\n): HashedTree {\n  if (!tree) throw new Error('taprootHashTree: empty tree');\n  if (Array.isArray(tree) && tree.length === 1) tree = tree[0];\n  // Terminal node (leaf)\n  if (!Array.isArray(tree)) {\n    const { leafVersion: version, script: leafScript } = tree;\n    // Earliest tree walk where we can validate tapScripts\n    if (tree.tapLeafScript || (tree.tapMerkleRoot && !u.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n      throw new Error('P2TR: tapRoot leafScript cannot have tree');\n    const script = typeof leafScript === 'string' ? hex.decode(leafScript) : leafScript;\n    if (!u.isBytes(script)) throw new Error(`checkScript: wrong script type=${script}`);\n    checkTaprootScript(script, internalPubKey, allowUnknownOutputs, customScripts);\n    return {\n      type: 'leaf',\n      version,\n      script,\n      hash: tapLeafHash(script, version),\n    };\n  }\n  // If tree / branch is not binary tree, convert it\n  if (tree.length !== 2) tree = taprootListToTree(tree as TaprootNode[]) as TaprootNode[];\n  if (tree.length !== 2) throw new Error('hashTree: non binary tree!');\n  // branch\n  // Both nodes should exist\n  const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs, customScripts);\n  const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs, customScripts);\n  // We cannot swap left/right here, since it will change structure of tree\n  let [lH, rH] = [left.hash, right.hash];\n  if (u.compareBytes(rH, lH) === -1) [lH, rH] = [rH, lH];\n  return { type: 'branch', left, right, hash: u.tagSchnorr('TapBranch', lH, rH) };\n}\n\nexport const TAP_LEAF_VERSION = 0xc0;\nexport const tapLeafHash = (script: Bytes, version: number = TAP_LEAF_VERSION): Bytes =>\n  u.tagSchnorr('TapLeaf', new Uint8Array([version]), VarBytes.encode(script));\n\n// Works as key OR tree.\n// If we only have tree, need to add unspendable key, otherwise\n// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY\nexport type P2TRRet<T> = T extends TaprootScriptTree ? P2TR_TREE : P2TR;\nexport function p2tr(\n  internalPubKey: Bytes | string,\n  tree?: undefined,\n  network?: BTC_NETWORK,\n  allowUnknownOutputs?: boolean,\n  customScripts?: CustomScript[]\n): Extends<P2TR, P2Ret>;\nexport function p2tr(\n  internalPubKey: Bytes | string,\n  tree: TaprootScriptTree,\n  network?: BTC_NETWORK,\n  allowUnknownOutputs?: boolean,\n  customScripts?: CustomScript[]\n): Extends<P2TR_TREE, P2Ret>;\nexport function p2tr(\n  internalPubKey?: Bytes | string,\n  tree?: TaprootScriptTree,\n  network: BTC_NETWORK = NETWORK,\n  allowUnknownOutputs = false,\n  customScripts?: CustomScript[]\n): Extends<P2TR & Partial<P2TR_TREE>, P2Ret> {\n  // Unspendable\n  if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n  const pubKey =\n    typeof internalPubKey === 'string'\n      ? hex.decode(internalPubKey)\n      : internalPubKey || u.TAPROOT_UNSPENDABLE_KEY;\n  if (!isValidPubkey(pubKey, u.PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');\n  if (tree) {\n    let hashedTree = taprootAddPath(\n      taprootHashTree(tree, pubKey, allowUnknownOutputs, customScripts)\n    );\n    const tapMerkleRoot = hashedTree.hash;\n    const [tweakedPubkey, parity] = u.taprootTweakPubkey(pubKey, tapMerkleRoot);\n    const leaves = taprootWalkTree(hashedTree).map((l) => ({\n      ...l,\n      controlBlock: TaprootControlBlock.encode({\n        version: (l.version || TAP_LEAF_VERSION) + parity,\n        internalKey: pubKey,\n        merklePath: l.path,\n      }),\n    }));\n    return {\n      type: 'tr',\n      script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n      address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n      // For tests\n      tweakedPubkey,\n      // PSBT stuff\n      tapInternalKey: pubKey,\n      leaves,\n      tapLeafScript: leaves.map((l) => [\n        TaprootControlBlock.decode(l.controlBlock),\n        u.concatBytes(l.script, new Uint8Array([l.version || TAP_LEAF_VERSION])),\n      ]),\n      tapMerkleRoot,\n    } as const satisfies P2TR_TREE;\n  } else {\n    const tweakedPubkey = u.taprootTweakPubkey(pubKey, P.EMPTY)[0];\n    return {\n      type: 'tr',\n      script: OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n      address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n      // For tests\n      tweakedPubkey,\n      // PSBT stuff\n      tapInternalKey: pubKey,\n    } as const satisfies P2TR;\n  }\n}\n\n// Returns all combinations of size M from lst\nexport function combinations<T>(m: number, list: T[]): T[][] {\n  const res: T[][] = [];\n  if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');\n  const n = list.length;\n  if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');\n  /*\n  Basically works as M nested loops like:\n  for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n  but since we cannot create nested loops dynamically, we unroll it to a single loop\n  */\n  const idx = Array.from({ length: m }, (_, i) => i);\n  const last = idx.length - 1;\n  main: for (;;) {\n    res.push(idx.map((i) => list[i]));\n    idx[last] += 1;\n    let i = last;\n    // Propagate increment\n    // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n    for (; i >= 0 && idx[i] > n - m + i; i--) {\n      idx[i] = 0;\n      // Overflow in idx[0], break\n      if (i === 0) break main;\n      idx[i - 1] += 1;\n    }\n    // Propagate: idx[i+1] = idx[idx]+1\n    for (i += 1; i < idx.length; i++) idx[i] = idx[i - 1] + 1;\n  }\n  return res;\n}\n\n/**\n * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.\n * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.\n * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`\n */\nexport type P2TR_NS = { type: 'tr_ns'; script: Bytes };\nexport const p2tr_ns = (\n  m: number,\n  pubkeys: Bytes[],\n  allowSamePubkeys = false\n): Extends<P2TR_NS, P2Ret>[] => {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return combinations(m, pubkeys).map(\n    (i) =>\n      ({\n        type: 'tr_ns',\n        script: OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n      }) as const\n  ) satisfies P2Ret[];\n};\n// Taproot public key (case of p2tr_ns)\nexport type P2TR_PK = P2TR_NS;\nexport const p2tr_pk = (pubkey: Bytes): Extends<P2TR_PK, P2Ret> =>\n  p2tr_ns(1, [pubkey], undefined)[0] satisfies P2Ret;\n\nexport type P2TR_MS = { type: 'tr_ms'; script: Bytes };\nexport function p2tr_ms(\n  m: number,\n  pubkeys: Bytes[],\n  allowSamePubkeys = false\n): Extends<P2TR_MS, P2Ret> {\n  if (!allowSamePubkeys) uniqPubkey(pubkeys);\n  return {\n    type: 'tr_ms',\n    script: OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n  } as const satisfies P2Ret;\n}\n\n// Simple pubkey address, without complex scripts\nexport function getAddress(\n  type: 'pkh' | 'wpkh' | 'tr',\n  privKey: Bytes,\n  network: BTC_NETWORK = NETWORK\n): string | undefined {\n  if (type === 'tr') {\n    return p2tr(u.pubSchnorr(privKey), undefined, network).address;\n  }\n  const pubKey = u.pubECDSA(privKey);\n  if (type === 'pkh') return p2pkh(pubKey, network).address;\n  if (type === 'wpkh') return p2wpkh(pubKey, network).address;\n  throw new Error(`getAddress: unknown type=${type}`);\n}\n\nexport const _sortPubkeys = (pubkeys: Bytes[]): Bytes[] => Array.from(pubkeys).sort(u.compareBytes);\n\nexport function multisig(\n  m: number,\n  pubkeys: Bytes[],\n  sorted = false,\n  witness = false,\n  network: BTC_NETWORK = NETWORK\n): P2Ret {\n  const ms = p2ms(m, sorted ? _sortPubkeys(pubkeys) : pubkeys);\n  return witness ? p2wsh(ms, network) : p2sh(ms, network);\n}\n\nexport function sortedMultisig(\n  m: number,\n  pubkeys: Bytes[],\n  witness = false,\n  network: BTC_NETWORK = NETWORK\n): P2Ret {\n  return multisig(m, pubkeys, true, witness, network);\n}\n\nconst base58check = createBase58check(u.sha256);\n\nfunction validateWitness(version: number, data: Bytes) {\n  if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');\n  if (version > 16) throw new Error('Witness: invalid version');\n  if (version === 0 && !(data.length === 20 || data.length === 32))\n    throw new Error('Witness: invalid length for version');\n}\n\nfunction programToWitness(version: number, data: Bytes, network = NETWORK) {\n  validateWitness(version, data);\n  const coder = version === 0 ? bech32 : bech32m;\n  return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\n\nfunction formatKey(hashed: Bytes, prefix: number[]): string {\n  return base58check.encode(u.concatBytes(Uint8Array.from(prefix), hashed));\n}\n\nexport function WIF(network: BTC_NETWORK = NETWORK): Coder<Bytes, string> {\n  return {\n    encode(privKey: Bytes) {\n      const compressed = u.concatBytes(privKey, new Uint8Array([0x01]));\n      return formatKey(compressed.subarray(0, 33), [network.wif]);\n    },\n    decode(wif: string) {\n      let parsed = base58check.decode(wif);\n      if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');\n      parsed = parsed.subarray(1);\n      // Check what it is. Compressed flag?\n      if (parsed.length !== 33) throw new Error('Wrong WIF length');\n      if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');\n      return parsed.subarray(0, -1);\n    },\n  };\n}\n\n// Returns OutType, which can be used to create outscript\nexport function Address(network: BTC_NETWORK = NETWORK) {\n  return {\n    encode(from: P.UnwrapCoder<OutScriptType>): string {\n      const { type } = from;\n      if (type === 'wpkh') return programToWitness(0, from.hash, network);\n      else if (type === 'wsh') return programToWitness(0, from.hash, network);\n      else if (type === 'tr') return programToWitness(1, from.pubkey, network);\n      else if (type === 'pkh') return formatKey(from.hash, [network.pubKeyHash]);\n      else if (type === 'sh') return formatKey(from.hash, [network.scriptHash]);\n      throw new Error(`Unknown address type=${type}`);\n    },\n    decode(address: string): P.UnwrapCoder<OutScriptType> {\n      if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');\n      // Bech32\n      if (network.bech32 && address.toLowerCase().startsWith(`${network.bech32}1`)) {\n        let res;\n        try {\n          res = bech32.decode(address as `${string}1${string}`);\n          if (res.words[0] !== 0) throw new Error(`bech32: wrong version=${res.words[0]}`);\n        } catch (_) {\n          // Starting from version 1 it is decoded as bech32m\n          res = bech32m.decode(address as `${string}1${string}`);\n          if (res.words[0] === 0) throw new Error(`bech32m: wrong version=${res.words[0]}`);\n        }\n        if (res.prefix !== network.bech32) throw new Error(`wrong bech32 prefix=${res.prefix}`);\n        const [version, ...program] = res.words;\n        const data = bech32.fromWords(program);\n        validateWitness(version, data);\n        if (version === 0 && data.length === 32) return { type: 'wsh', hash: data };\n        else if (version === 0 && data.length === 20) return { type: 'wpkh', hash: data };\n        else if (version === 1 && data.length === 32) return { type: 'tr', pubkey: data };\n        else throw new Error('Unknown witness program');\n      }\n      const data = base58check.decode(address);\n      if (data.length !== 21) throw new Error('Invalid base58 address');\n      // Pay To Public Key Hash\n      if (data[0] === network.pubKeyHash) {\n        return { type: 'pkh', hash: data.slice(1) };\n      } else if (data[0] === network.scriptHash) {\n        return {\n          type: 'sh',\n          hash: data.slice(1),\n        };\n      }\n      throw new Error(`Invalid address prefix=${data[0]}`);\n    },\n  };\n}\n", "import { hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport { Address, type CustomScript, OutScript, checkScript, tapLeafHash } from './payment.ts';\nimport * as psbt from './psbt.ts';\nimport {\n  CompactSizeLen,\n  RawOldTx,\n  RawOutput,\n  RawTx,\n  RawWitness,\n  Script,\n  VarBytes,\n} from './script.ts';\nimport * as u from './utils.ts';\nimport { type Bytes, NETWORK, concatBytes, equalBytes, isBytes } from './utils.ts';\n\nconst EMPTY32 = new Uint8Array(32);\nconst EMPTY_OUTPUT: P.UnwrapCoder<typeof RawOutput> = {\n  amount: 0xffffffffffffffffn,\n  script: P.EMPTY,\n};\nexport const toVsize = (weight: number): number => Math.ceil(weight / 4);\n\n// @scure/bip32 interface\ninterface HDKey {\n  publicKey: Bytes;\n  privateKey: Bytes;\n  fingerprint: number;\n  derive(path: string): HDKey;\n  deriveChild(index: number): HDKey;\n  sign(hash: Bytes): Bytes;\n}\n\nexport type Signer = Bytes | HDKey;\n\nexport const PRECISION = 8;\nexport const DEFAULT_VERSION = 2;\nexport const DEFAULT_LOCKTIME = 0;\nexport const DEFAULT_SEQUENCE = 4294967295;\nexport const Decimal: P.Coder<bigint, string> = P.coders.decimal(PRECISION);\n\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nexport const def = <T>(value: T | undefined, def: T): T => (value === undefined ? def : value);\n\nexport function cloneDeep<T>(obj: T): T {\n  if (Array.isArray(obj)) return obj.map((i) => cloneDeep(i)) as unknown as T;\n  // slice of nodejs Buffer doesn't copy\n  else if (isBytes(obj)) return Uint8Array.from(obj) as unknown as T;\n  // immutable\n  else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj)) return obj;\n  // null is object\n  else if (obj === null) return obj;\n  // should be last, so it won't catch other types\n  else if (typeof obj === 'object') {\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)])\n    ) as unknown as T;\n  }\n  throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\n\n// Mostly security features, hardened defaults;\n// but you still can parse other people tx with unspendable outputs and stuff if you want\nexport interface TxOpts {\n  version?: number;\n  lockTime?: number;\n  PSBTVersion?: number;\n  // Flags\n  // Allow non-standard transaction version\n  allowUnknownVersion?: boolean;\n  // Allow output scripts to be unknown scripts (probably unspendable)\n  /** @deprecated Use `allowUnknownOutputs` */\n  allowUnknowOutput?: boolean;\n  allowUnknownOutputs?: boolean;\n  // Try to sign/finalize unknown input. All bets are off, but there is chance that it will work\n  /** @deprecated Use `allowUnknownInputs` */\n  allowUnknowInput?: boolean;\n  allowUnknownInputs?: boolean;\n  // Check input/output scripts for sanity\n  disableScriptCheck?: boolean;\n  // There is strange behaviour where tx without outputs encoded with empty output in the end,\n  // tx without outputs in BIP174 doesn't have itb\n  bip174jsCompat?: boolean;\n  // If transaction data comes from untrusted source, then it can be modified in such way that will\n  // result paying higher mining fee\n  allowLegacyWitnessUtxo?: boolean;\n  lowR?: boolean; // Use lowR signatures\n  customScripts?: CustomScript[]; // UNSAFE: Custom payment scripts\n  // Allow to add additional unknown keys/values to the \"unknown\" array member\n  allowUnknown?: boolean;\n}\n\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nexport enum SignatureHash {\n  DEFAULT,\n  ALL,\n  NONE,\n  SINGLE,\n  ANYONECANPAY = 0x80,\n}\n\nexport enum SigHash {\n  DEFAULT = SignatureHash.DEFAULT,\n  ALL = SignatureHash.ALL,\n  NONE = SignatureHash.NONE,\n  SINGLE = SignatureHash.SINGLE,\n  DEFAULT_ANYONECANPAY = SignatureHash.DEFAULT | SignatureHash.ANYONECANPAY,\n  ALL_ANYONECANPAY = SignatureHash.ALL | SignatureHash.ANYONECANPAY,\n  NONE_ANYONECANPAY = SignatureHash.NONE | SignatureHash.ANYONECANPAY,\n  SINGLE_ANYONECANPAY = SignatureHash.SINGLE | SignatureHash.ANYONECANPAY,\n}\n\nfunction getTaprootKeys(\n  privKey: Bytes,\n  pubKey: Bytes,\n  internalKey: Bytes,\n  merkleRoot: Bytes = P.EMPTY\n) {\n  if (equalBytes(internalKey, pubKey)) {\n    privKey = u.taprootTweakPrivKey(privKey, merkleRoot);\n    pubKey = u.pubSchnorr(privKey);\n  }\n  return { privKey, pubKey };\n}\n\n// User facing API with decoders\nexport type TransactionInputRequired = {\n  txid: Bytes;\n  index: number;\n  sequence: number;\n  finalScriptSig: Bytes;\n};\n\n// Force check amount/script\nfunction outputBeforeSign(i: psbt.TransactionOutput): psbt.TransactionOutputRequired {\n  if (i.script === undefined || i.amount === undefined)\n    throw new Error('Transaction/output: script and amount required');\n  return { script: i.script, amount: i.amount };\n}\n\n// Force check index/txid/sequence\nexport function inputBeforeSign(i: psbt.TransactionInput): TransactionInputRequired {\n  if (i.txid === undefined || i.index === undefined)\n    throw new Error('Transaction/input: txid and index required');\n  return {\n    txid: i.txid,\n    index: i.index,\n    sequence: def(i.sequence, DEFAULT_SEQUENCE),\n    finalScriptSig: def(i.finalScriptSig, P.EMPTY),\n  };\n}\nfunction cleanFinalInput(i: psbt.TransactionInput) {\n  for (const _k in i) {\n    const k = _k as keyof psbt.TransactionInput;\n    if (!psbt.PSBTInputFinalKeys.includes(k)) delete i[k];\n  }\n}\n\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\n\nfunction validateSigHash(s: SigHash) {\n  if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n    throw new Error(`Invalid SigHash=${s}`);\n  return s;\n}\n\nfunction unpackSighash(hashType: number) {\n  const masked = hashType & 0b0011111;\n  return {\n    isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n    isNone: masked === SignatureHash.NONE,\n    isSingle: masked === SignatureHash.SINGLE,\n  };\n}\n\nfunction validateOpts(opts: TxOpts): Readonly<TxOpts> {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error(`Wrong object type for transaction options: ${opts}`);\n\n  const _opts = {\n    ...opts,\n    // Defaults\n    version: def(opts.version, DEFAULT_VERSION),\n    lockTime: def(opts.lockTime, 0),\n    PSBTVersion: def(opts.PSBTVersion, 0),\n  };\n  if (typeof _opts.allowUnknowInput !== 'undefined')\n    opts.allowUnknownInputs = _opts.allowUnknowInput;\n  if (typeof _opts.allowUnknowOutput !== 'undefined')\n    opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n  if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');\n  P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n  // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n  // can lead to constructing broken transactions\n  if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n    throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n  // Flags\n  for (const k of [\n    'allowUnknownVersion',\n    'allowUnknownOutputs',\n    'allowUnknownInputs',\n    'disableScriptCheck',\n    'bip174jsCompat',\n    'allowLegacyWitnessUtxo',\n    'lowR',\n  ] as const) {\n    const v = _opts[k];\n    if (v === undefined) continue; // optional\n    if (typeof v !== 'boolean')\n      throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n  }\n  // 0 and -1 happens in tests\n  if (\n    _opts.allowUnknownVersion\n      ? typeof _opts.version === 'number'\n      : ![-1, 0, 1, 2, 3].includes(_opts.version)\n  )\n    throw new Error(`Unknown version: ${_opts.version}`);\n  if (_opts.customScripts !== undefined) {\n    const cs = _opts.customScripts;\n    if (!Array.isArray(cs)) {\n      throw new Error(\n        `wrong custom scripts type (expected array): customScripts=${cs} (${typeof cs})`\n      );\n    }\n    for (const s of cs) {\n      if (typeof s.encode !== 'function' || typeof s.decode !== 'function')\n        throw new Error(`wrong script=${s} (${typeof s})`);\n      if (s.finalizeTaproot !== undefined && typeof s.finalizeTaproot !== 'function')\n        throw new Error(`wrong script=${s} (${typeof s})`);\n    }\n  }\n  return Object.freeze(_opts);\n}\n\n// NOTE: we cannot do this inside PSBTInput coder, because there is no index/txid at this point!\nfunction validateInput(i: psbt.TransactionInput): psbt.TransactionInput {\n  if (i.nonWitnessUtxo && i.index !== undefined) {\n    const last = i.nonWitnessUtxo.outputs.length - 1;\n    if (i.index > last) throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n    const prevOut = i.nonWitnessUtxo.outputs[i.index];\n    if (\n      i.witnessUtxo &&\n      (!equalBytes(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount)\n    )\n      throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n    if (i.txid) {\n      const outputs = i.nonWitnessUtxo.outputs;\n      if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');\n      // At this point, we are using previous tx output to create new input.\n      // Script safety checks are unnecessary:\n      // - User has no control over previous tx. If somebody send money in same tx\n      //   as unspendable output, we still want user able to spend money\n      // - We still want some checks to notify user about possible errors early\n      //   in case user wants to use wrong input by mistake\n      // - Worst case: tx will be rejected by nodes. Still better than disallowing user\n      //   to spend real input, no matter how broken it looks\n      const tx = Transaction.fromRaw(RawTx.encode(i.nonWitnessUtxo), {\n        allowUnknownOutputs: true,\n        disableScriptCheck: true,\n        allowUnknownInputs: true,\n      });\n      const txid = hex.encode(i.txid);\n      // PSBTv2 vectors have non-final tx in inputs\n      if (tx.isFinal && tx.id !== txid)\n        throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n    }\n  }\n  return i;\n}\n\nexport type PSBTInputs = psbt.PSBTKeyMapKeys<typeof psbt.PSBTInput>;\n\n// Normalizes input\nexport function getPrevOut(input: psbt.TransactionInput): P.UnwrapCoder<typeof RawOutput> {\n  if (input.nonWitnessUtxo) {\n    if (input.index === undefined) throw new Error('Unknown input index');\n    return input.nonWitnessUtxo.outputs[input.index];\n  } else if (input.witnessUtxo) return input.witnessUtxo;\n  else throw new Error('Cannot find previous output info');\n}\n\nexport function normalizeInput(\n  i: psbt.TransactionInputUpdate,\n  cur?: psbt.TransactionInput,\n  allowedFields?: (keyof psbt.TransactionInput)[],\n  disableScriptCheck = false,\n  allowUnknown = false\n): psbt.TransactionInput {\n  let { nonWitnessUtxo, txid } = i;\n  // String support for common fields. We usually prefer Uint8Array to avoid errors\n  // like hex looking string accidentally passed, however, in case of nonWitnessUtxo\n  // it is better to expect string, since constructing this complex object will be\n  // difficult for user\n  if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = hex.decode(nonWitnessUtxo);\n  if (isBytes(nonWitnessUtxo)) nonWitnessUtxo = RawTx.decode(nonWitnessUtxo);\n  if (!('nonWitnessUtxo' in i) && nonWitnessUtxo === undefined)\n    nonWitnessUtxo = cur?.nonWitnessUtxo;\n  if (typeof txid === 'string') txid = hex.decode(txid);\n  // TODO: if we have nonWitnessUtxo, we can extract txId from here\n  if (txid === undefined) txid = cur?.txid;\n  let res: PSBTInputs = { ...cur, ...i, nonWitnessUtxo, txid };\n  if (!('nonWitnessUtxo' in i) && res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;\n  if (res.sequence === undefined) res.sequence = DEFAULT_SEQUENCE;\n  if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;\n  res = psbt.mergeKeyMap(psbt.PSBTInput, res, cur, allowedFields, allowUnknown);\n  psbt.PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n\n  let prevOut;\n  if (res.nonWitnessUtxo && res.index !== undefined)\n    prevOut = res.nonWitnessUtxo.outputs[res.index];\n  else if (res.witnessUtxo) prevOut = res.witnessUtxo;\n  if (prevOut && !disableScriptCheck)\n    checkScript(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n  return res;\n}\n\nexport function getInputType(input: psbt.TransactionInput, allowLegacyWitnessUtxo = false) {\n  let txType = 'legacy';\n  let defaultSighash = SignatureHash.ALL;\n  const prevOut = getPrevOut(input);\n  const first = OutScript.decode(prevOut.script);\n  let type = first.type;\n  let cur = first;\n  const stack = [first];\n  if (first.type === 'tr') {\n    defaultSighash = SignatureHash.DEFAULT;\n    return {\n      txType: 'taproot',\n      type: 'tr',\n      last: first,\n      lastScript: prevOut.script,\n      defaultSighash,\n      sighash: input.sighashType || defaultSighash,\n    };\n  } else {\n    if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';\n    if (first.type === 'sh') {\n      if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');\n      let child = OutScript.decode(input.redeemScript);\n      if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';\n      stack.push(child);\n      cur = child;\n      type += `-${child.type}`;\n    }\n    // wsh can be inside sh\n    if (cur.type === 'wsh') {\n      if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');\n      let child = OutScript.decode(input.witnessScript);\n      if (child.type === 'wsh') txType = 'segwit';\n      stack.push(child);\n      cur = child;\n      type += `-${child.type}`;\n    }\n    const last = stack[stack.length - 1];\n    if (last.type === 'sh' || last.type === 'wsh')\n      throw new Error('inputType: sh/wsh cannot be terminal type');\n    const lastScript = OutScript.encode(last);\n    const res = {\n      type,\n      txType,\n      last,\n      lastScript,\n      defaultSighash,\n      sighash: input.sighashType || defaultSighash,\n    };\n    if (txType === 'legacy' && !allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n      throw new Error(\n        `Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`\n      );\n    }\n    return res;\n  }\n}\n\nexport class Transaction {\n  private global: psbt.PSBTKeyMapKeys<typeof psbt.PSBTGlobal> = {};\n  private inputs: psbt.TransactionInput[] = []; // use getInput()\n  private outputs: psbt.TransactionOutput[] = []; // use getOutput()\n  readonly opts: ReturnType<typeof validateOpts>;\n  constructor(opts: TxOpts = {}) {\n    const _opts = (this.opts = validateOpts(opts));\n    // Merge with global structure of PSBTv2\n    if (_opts.lockTime !== DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;\n    this.global.txVersion = _opts.version;\n  }\n\n  // Import\n  static fromRaw(raw: Bytes, opts: TxOpts = {}): Transaction {\n    const parsed = RawTx.decode(raw);\n    const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n    for (const o of parsed.outputs) tx.addOutput(o);\n    tx.outputs = parsed.outputs;\n    tx.inputs = parsed.inputs;\n    if (parsed.witnesses) {\n      for (let i = 0; i < parsed.witnesses.length; i++)\n        tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n    }\n    return tx;\n  }\n  // PSBT\n  static fromPSBT(psbt_: Bytes, opts: TxOpts = {}): Transaction {\n    let parsed: P.UnwrapCoder<typeof psbt.RawPSBTV0>;\n    try {\n      parsed = psbt.RawPSBTV0.decode(psbt_);\n    } catch (e0) {\n      try {\n        parsed = psbt.RawPSBTV2.decode(psbt_);\n      } catch (e2) {\n        // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n        throw e0;\n      }\n    }\n    const PSBTVersion = parsed.global.version || 0;\n    if (PSBTVersion !== 0 && PSBTVersion !== 2)\n      throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    const unsigned = parsed.global.unsignedTx;\n    const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n    const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n    const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n    // We need slice here, because otherwise\n    const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n    tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) =>\n      validateInput({\n        finalScriptSig: P.EMPTY,\n        ...parsed.global.unsignedTx?.inputs[j],\n        ...i,\n      })\n    );\n    const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n    tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n      ...i,\n      ...parsed.global.unsignedTx?.outputs[j],\n    }));\n    tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n    if (lockTime !== DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;\n    return tx;\n  }\n  toPSBT(PSBTVersion: number | undefined = this.opts.PSBTVersion): Uint8Array {\n    if (PSBTVersion !== 0 && PSBTVersion !== 2)\n      throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n    // if (PSBTVersion === 0 && this.inputs.length === 0) {\n    //   throw new Error(\n    //     'PSBT version=0 export for transaction without inputs disabled, please use version=2. Please check `toPSBT` method for explanation.'\n    //   );\n    // }\n    const inputs = this.inputs.map((i) =>\n      validateInput(psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTInput, i))\n    );\n    for (const inp of inputs) {\n      // Don't serialize empty fields\n      if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;\n      if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;\n      if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;\n    }\n    const outputs = this.outputs.map((i) => psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTOutput, i));\n    const global = { ...this.global };\n    if (PSBTVersion === 0) {\n      /*\n      - Bitcoin raw transaction expects to have at least 1 input because it uses case with zero inputs as marker for SegWit\n      - this means we cannot serialize raw tx with zero inputs since it will be parsed as SegWit tx\n      - Parsing of PSBTv0 depends on unsignedTx (it looks for input count here)\n      - BIP-174 requires old serialization format (without witnesses) inside global, which solves this\n      */\n      global.unsignedTx = RawOldTx.decode(\n        RawOldTx.encode({\n          version: this.version,\n          lockTime: this.lockTime,\n          inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n            ...i,\n            finalScriptSig: P.EMPTY,\n          })),\n          outputs: this.outputs.map(outputBeforeSign),\n        })\n      );\n      delete global.fallbackLocktime;\n      delete global.txVersion;\n    } else {\n      global.version = PSBTVersion;\n      global.txVersion = this.version;\n      global.inputCount = this.inputs.length;\n      global.outputCount = this.outputs.length;\n      if (global.fallbackLocktime && global.fallbackLocktime === DEFAULT_LOCKTIME)\n        delete global.fallbackLocktime;\n    }\n    if (this.opts.bip174jsCompat) {\n      if (!inputs.length) inputs.push({});\n      if (!outputs.length) outputs.push({});\n    }\n    return (PSBTVersion === 0 ? psbt.RawPSBTV0 : psbt.RawPSBTV2).encode({\n      global,\n      inputs,\n      outputs,\n    });\n  }\n\n  // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n  get lockTime(): number {\n    let height = DEFAULT_LOCKTIME;\n    let heightCnt = 0;\n    let time = DEFAULT_LOCKTIME;\n    let timeCnt = 0;\n    for (const i of this.inputs) {\n      if (i.requiredHeightLocktime) {\n        height = Math.max(height, i.requiredHeightLocktime);\n        heightCnt++;\n      }\n      if (i.requiredTimeLocktime) {\n        time = Math.max(time, i.requiredTimeLocktime);\n        timeCnt++;\n      }\n    }\n    if (heightCnt && heightCnt >= timeCnt) return height;\n    if (time !== DEFAULT_LOCKTIME) return time;\n    return this.global.fallbackLocktime || DEFAULT_LOCKTIME;\n  }\n\n  get version(): number {\n    // Should be not possible\n    if (this.global.txVersion === undefined) throw new Error('No global.txVersion');\n    return this.global.txVersion;\n  }\n\n  private inputStatus(idx: number) {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    // Finalized\n    if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';\n    if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';\n    // Signed taproot\n    if (input.tapKeySig) return 'signed';\n    if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';\n    // Signed\n    if (input.partialSig && input.partialSig.length) return 'signed';\n    return 'unsigned';\n  }\n  // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n  // We will lose some vectors -> smaller test coverage of preimages (very important!)\n  private inputSighash(idx: number) {\n    this.checkInputIdx(idx);\n    const inputSighash = this.inputs[idx].sighashType;\n    const sighash = inputSighash === undefined ? SignatureHash.DEFAULT : inputSighash;\n    // ALL or DEFAULT -- everything signed\n    // NONE           -- all inputs + no outputs\n    // SINGLE         -- all inputs + output with same index\n    // ALL + ANYONE   -- specific input + all outputs\n    // NONE + ANYONE  -- specific input + no outputs\n    // SINGLE         -- specific inputs + output with same index\n    const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n    const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n    return { sigInputs, sigOutputs };\n  }\n  // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n  // Some cache will be nice, but there chance to have bugs with cache invalidation\n  private signStatus() {\n    // if addInput or addOutput is not possible, then all inputs or outputs are signed\n    let addInput = true,\n      addOutput = true;\n    let inputs = [],\n      outputs = [];\n    for (let idx = 0; idx < this.inputs.length; idx++) {\n      const status = this.inputStatus(idx);\n      // Unsigned input doesn't affect anything\n      if (status === 'unsigned') continue;\n      const { sigInputs, sigOutputs } = this.inputSighash(idx);\n      // Input type\n      if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);\n      else addInput = false;\n      // Output type\n      if (sigOutputs === SignatureHash.ALL) addOutput = false;\n      else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);\n      else if (sigOutputs === SignatureHash.NONE) {\n        // Doesn't affect any outputs at all\n      } else throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n    }\n    return { addInput, addOutput, inputs, outputs };\n  }\n\n  get isFinal(): boolean {\n    for (let idx = 0; idx < this.inputs.length; idx++)\n      if (this.inputStatus(idx) !== 'finalized') return false;\n    return true;\n  }\n\n  // Info utils\n  get hasWitnesses(): boolean {\n    let out = false;\n    for (const i of this.inputs)\n      if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;\n    return out;\n  }\n  // https://en.bitcoin.it/wiki/Weight_units\n  get weight(): number {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    let out = 32;\n    // Outputs\n    const outputs = this.outputs.map(outputBeforeSign);\n    out += 4 * CompactSizeLen.encode(this.outputs.length).length;\n    for (const o of outputs) out += 32 + 4 * VarBytes.encode(o.script).length;\n    // Inputs\n    if (this.hasWitnesses) out += 2;\n    out += 4 * CompactSizeLen.encode(this.inputs.length).length;\n    for (const i of this.inputs) {\n      out += 160 + 4 * VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n      if (this.hasWitnesses && i.finalScriptWitness)\n        out += RawWitness.encode(i.finalScriptWitness).length;\n    }\n    return out;\n  }\n  get vsize(): number {\n    return toVsize(this.weight);\n  }\n  toBytes(withScriptSig = false, withWitness = false): Uint8Array {\n    return RawTx.encode({\n      version: this.version,\n      lockTime: this.lockTime,\n      inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n        ...i,\n        finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n      })),\n      outputs: this.outputs.map(outputBeforeSign),\n      witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n      segwitFlag: withWitness && this.hasWitnesses,\n    });\n  }\n  get unsignedTx(): Bytes {\n    return this.toBytes(false, false);\n  }\n  get hex(): string {\n    return hex.encode(this.toBytes(true, this.hasWitnesses));\n  }\n\n  get hash(): string {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(u.sha256x2(this.toBytes(true)));\n  }\n  get id(): string {\n    if (!this.isFinal) throw new Error('Transaction is not finalized');\n    return hex.encode(u.sha256x2(this.toBytes(true)).reverse());\n  }\n  // Input stuff\n  private checkInputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n      throw new Error(`Wrong input index=${idx}`);\n  }\n  getInput(idx: number): psbt.TransactionInput {\n    this.checkInputIdx(idx);\n    return cloneDeep(this.inputs[idx]);\n  }\n  get inputsLength(): number {\n    return this.inputs.length;\n  }\n  // Modification\n  addInput(input: psbt.TransactionInputUpdate, _ignoreSignStatus = false): number {\n    if (!_ignoreSignStatus && !this.signStatus().addInput)\n      throw new Error('Tx has signed inputs, cannot add new one');\n    this.inputs.push(normalizeInput(input, undefined, undefined, this.opts.disableScriptCheck));\n    return this.inputs.length - 1;\n  }\n  updateInput(idx: number, input: psbt.TransactionInputUpdate, _ignoreSignStatus = false): void {\n    this.checkInputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addInput || status.inputs.includes(idx))\n        allowedFields = psbt.PSBTInputUnsignedKeys;\n    }\n    this.inputs[idx] = normalizeInput(\n      input,\n      this.inputs[idx],\n      allowedFields,\n      this.opts.disableScriptCheck,\n      this.opts.allowUnknown\n    );\n  }\n  // Output stuff\n  private checkOutputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n      throw new Error(`Wrong output index=${idx}`);\n  }\n  getOutput(idx: number): psbt.TransactionOutput {\n    this.checkOutputIdx(idx);\n    return cloneDeep(this.outputs[idx]);\n  }\n  getOutputAddress(idx: number, network: u.BTC_NETWORK = NETWORK): string | undefined {\n    const out = this.getOutput(idx);\n    if (!out.script) return;\n    return Address(network).encode(OutScript.decode(out.script));\n  }\n\n  get outputsLength(): number {\n    return this.outputs.length;\n  }\n  private normalizeOutput(\n    o: psbt.TransactionOutputUpdate,\n    cur?: psbt.TransactionOutput,\n    allowedFields?: (keyof typeof psbt.PSBTOutput)[]\n  ): psbt.TransactionOutput {\n    let { amount, script } = o;\n    if (amount === undefined) amount = cur?.amount;\n    if (typeof amount !== 'bigint')\n      throw new Error(\n        `Wrong amount type, should be of type bigint in sats, but got ${amount} of type ${typeof amount}`\n      );\n    if (typeof script === 'string') script = hex.decode(script);\n    if (script === undefined) script = cur?.script;\n    let res: psbt.PSBTKeyMapKeys<typeof psbt.PSBTOutput> = { ...cur, ...o, amount, script };\n    if (res.amount === undefined) delete res.amount;\n    res = psbt.mergeKeyMap(psbt.PSBTOutput, res, cur, allowedFields, this.opts.allowUnknown);\n    psbt.PSBTOutputCoder.encode(res);\n    if (\n      res.script &&\n      !this.opts.allowUnknownOutputs &&\n      OutScript.decode(res.script).type === 'unknown'\n    ) {\n      throw new Error(\n        'Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure'\n      );\n    }\n    if (!this.opts.disableScriptCheck) checkScript(res.script, res.redeemScript, res.witnessScript);\n    return res;\n  }\n  addOutput(o: psbt.TransactionOutputUpdate, _ignoreSignStatus = false): number {\n    if (!_ignoreSignStatus && !this.signStatus().addOutput)\n      throw new Error('Tx has signed outputs, cannot add new one');\n    this.outputs.push(this.normalizeOutput(o));\n    return this.outputs.length - 1;\n  }\n  updateOutput(idx: number, output: psbt.TransactionOutputUpdate, _ignoreSignStatus = false): void {\n    this.checkOutputIdx(idx);\n    let allowedFields = undefined;\n    if (!_ignoreSignStatus) {\n      const status = this.signStatus();\n      if (!status.addOutput || status.outputs.includes(idx))\n        allowedFields = psbt.PSBTOutputUnsignedKeys;\n    }\n    this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n  }\n  addOutputAddress(address: string, amount: bigint, network: u.BTC_NETWORK = NETWORK): number {\n    return this.addOutput({ script: OutScript.encode(Address(network).decode(address)), amount });\n  }\n  // Utils\n  get fee(): bigint {\n    let res = 0n;\n    for (const i of this.inputs) {\n      const prevOut = getPrevOut(i);\n      if (!prevOut) throw new Error('Empty input amount');\n      res += prevOut.amount;\n    }\n    const outputs = this.outputs.map(outputBeforeSign);\n    for (const o of outputs) res -= o.amount;\n    return res;\n  }\n\n  // Signing\n  // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n  // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n  // but we are trying to be less complicated for audit purpose for now.\n  private preimageLegacy(idx: number, prevOutScript: Bytes, hashType: number) {\n    const { isAny, isNone, isSingle } = unpackSighash(hashType);\n    if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error(`Invalid input idx=${idx}`);\n    if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n      return P.U256BE.encode(1n);\n    prevOutScript = Script.encode(\n      Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR')\n    );\n    let inputs: TransactionInputRequired[] = this.inputs\n      .map(inputBeforeSign)\n      .map((input, inputIdx) => ({\n        ...input,\n        finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n      }));\n    if (isAny) inputs = [inputs[idx]];\n    else if (isNone || isSingle) {\n      inputs = inputs.map((input, inputIdx) => ({\n        ...input,\n        sequence: inputIdx === idx ? input.sequence : 0,\n      }));\n    }\n    let outputs = this.outputs.map(outputBeforeSign);\n    if (isNone) outputs = [];\n    else if (isSingle) {\n      outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n    }\n    const tmpTx = RawTx.encode({\n      lockTime: this.lockTime,\n      version: this.version,\n      segwitFlag: false,\n      inputs,\n      outputs,\n    });\n    return u.sha256x2(tmpTx, P.I32LE.encode(hashType));\n  }\n  preimageWitnessV0(\n    idx: number,\n    prevOutScript: Bytes,\n    hashType: number,\n    amount: bigint\n  ): Uint8Array {\n    const { isAny, isNone, isSingle } = unpackSighash(hashType);\n    let inputHash = EMPTY32;\n    let sequenceHash = EMPTY32;\n    let outputHash = EMPTY32;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (!isAny) inputHash = u.sha256x2(...inputs.map(TxHashIdx.encode));\n    if (!isAny && !isSingle && !isNone)\n      sequenceHash = u.sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n    if (!isSingle && !isNone) {\n      outputHash = u.sha256x2(...outputs.map(RawOutput.encode));\n    } else if (isSingle && idx < outputs.length)\n      outputHash = u.sha256x2(RawOutput.encode(outputs[idx]));\n    const input = inputs[idx];\n    return u.sha256x2(\n      P.I32LE.encode(this.version),\n      inputHash,\n      sequenceHash,\n      P.bytes(32, true).encode(input.txid),\n      P.U32LE.encode(input.index),\n      VarBytes.encode(prevOutScript),\n      P.U64LE.encode(amount),\n      P.U32LE.encode(input.sequence),\n      outputHash,\n      P.U32LE.encode(this.lockTime),\n      P.U32LE.encode(hashType)\n    );\n  }\n  preimageWitnessV1(\n    idx: number,\n    prevOutScript: Bytes[],\n    hashType: number,\n    amount: bigint[],\n    codeSeparator = -1,\n    leafScript?: Bytes,\n    leafVer = 0xc0,\n    annex?: Bytes\n  ): Uint8Array {\n    if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n      throw new Error(`Invalid amounts array=${amount}`);\n    if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n      throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n    const out: Bytes[] = [\n      P.U8.encode(0),\n      P.U8.encode(hashType), // U8 sigHash\n      P.I32LE.encode(this.version),\n      P.U32LE.encode(this.lockTime),\n    ];\n    const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n    const inType = hashType & SignatureHash.ANYONECANPAY;\n    const inputs = this.inputs.map(inputBeforeSign);\n    const outputs = this.outputs.map(outputBeforeSign);\n    if (inType !== SignatureHash.ANYONECANPAY) {\n      out.push(\n        ...[\n          inputs.map(TxHashIdx.encode),\n          amount.map(P.U64LE.encode),\n          prevOutScript.map(VarBytes.encode),\n          inputs.map((i) => P.U32LE.encode(i.sequence)),\n        ].map((i) => u.sha256(concatBytes(...i)))\n      );\n    }\n    if (outType === SignatureHash.ALL) {\n      out.push(u.sha256(concatBytes(...outputs.map(RawOutput.encode))));\n    }\n    const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n    out.push(new Uint8Array([spendType]));\n    if (inType === SignatureHash.ANYONECANPAY) {\n      const inp = inputs[idx];\n      out.push(\n        TxHashIdx.encode(inp),\n        P.U64LE.encode(amount[idx]),\n        VarBytes.encode(prevOutScript[idx]),\n        P.U32LE.encode(inp.sequence)\n      );\n    } else out.push(P.U32LE.encode(idx));\n    if (spendType & 1) out.push(u.sha256(VarBytes.encode(annex || P.EMPTY)));\n    if (outType === SignatureHash.SINGLE)\n      out.push(idx < outputs.length ? u.sha256(RawOutput.encode(outputs[idx])) : EMPTY32);\n    if (leafScript)\n      out.push(tapLeafHash(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n    return u.tagSchnorr('TapSighash', ...out);\n  }\n  // Signer can be privateKey OR instance of bip32 HD stuff\n  signIdx(privateKey: Signer, idx: number, allowedSighash?: SigHash[], _auxRand?: Bytes): boolean {\n    this.checkInputIdx(idx);\n    const input = this.inputs[idx];\n    const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n    // Handle BIP32 HDKey\n    if (!isBytes(privateKey)) {\n      if (!input.bip32Derivation || !input.bip32Derivation.length)\n        throw new Error('bip32Derivation: empty');\n      const signers = input.bip32Derivation\n        .filter((i) => i[1].fingerprint == (privateKey as HDKey).fingerprint)\n        .map(([pubKey, { path }]) => {\n          let s = privateKey as HDKey;\n          for (const i of path) s = s.deriveChild(i);\n          if (!equalBytes(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');\n          if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');\n          return s;\n        });\n      if (!signers.length)\n        throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n      let signed = false;\n      for (const s of signers) if (this.signIdx(s.privateKey, idx)) signed = true;\n      return signed;\n    }\n    // Sighash checks\n    // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n    if (!allowedSighash) allowedSighash = [inputType.defaultSighash as unknown as SigHash];\n    else allowedSighash.forEach(validateSigHash);\n    const sighash = inputType.sighash;\n    if (!allowedSighash.includes(sighash)) {\n      throw new Error(\n        `Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`\n      );\n    }\n    // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n    // however this was because of bug in bitcoin-core, which remains here because of consensus.\n    // If this is absolutely neccessary for your case, please open issue.\n    // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n    const { sigOutputs } = this.inputSighash(idx);\n    if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n      throw new Error(\n        `Input with sighash SINGLE, but there is no output with corresponding index=${idx}`\n      );\n    }\n\n    // Actual signing\n    // Taproot\n    const prevOut = getPrevOut(input);\n    if (inputType.txType === 'taproot') {\n      const prevOuts = this.inputs.map(getPrevOut);\n      const prevOutScript = prevOuts.map((i) => i.script);\n      const amount = prevOuts.map((i) => i.amount);\n      let signed = false;\n      let schnorrPub = u.pubSchnorr(privateKey);\n      let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n      if (input.tapInternalKey) {\n        // internal + tweak = tweaked key\n        // if internal key == current public key, we need to tweak private key,\n        // otherwise sign as is. bitcoinjs implementation always wants tweaked\n        // priv key to be provided\n        const { pubKey, privKey } = getTaprootKeys(\n          privateKey,\n          schnorrPub,\n          input.tapInternalKey,\n          merkleRoot\n        );\n        const [taprootPubKey, _] = u.taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n        if (equalBytes(taprootPubKey, pubKey)) {\n          const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n          const sig = concatBytes(\n            u.signSchnorr(hash, privKey, _auxRand),\n            sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY\n          );\n          this.updateInput(idx, { tapKeySig: sig }, true);\n          signed = true;\n        }\n      }\n      if (input.tapLeafScript) {\n        input.tapScriptSig = input.tapScriptSig || [];\n        for (const [_, _script] of input.tapLeafScript) {\n          const script = _script.subarray(0, -1);\n          const scriptDecoded = Script.decode(script);\n          const ver = _script[_script.length - 1];\n          const hash = tapLeafHash(script, ver);\n          // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n          const pos = scriptDecoded.findIndex((i) => isBytes(i) && equalBytes(i, schnorrPub));\n          // Skip if there is no public key in tapLeafScript\n          if (pos === -1) continue;\n          const msg = this.preimageWitnessV1(\n            idx,\n            prevOutScript,\n            sighash,\n            amount,\n            undefined,\n            script,\n            ver\n          );\n          const sig = concatBytes(\n            u.signSchnorr(msg, privateKey, _auxRand),\n            sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY\n          );\n          this.updateInput(\n            idx,\n            { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] },\n            true\n          );\n          signed = true;\n        }\n      }\n      if (!signed) throw new Error('No taproot scripts signed');\n      return true;\n    } else {\n      // only compressed keys are supported for now\n      const pubKey = u.pubECDSA(privateKey);\n      // TODO: replace with explicit checks\n      // Check if script has public key or its has inside\n      let hasPubkey = false;\n      const pubKeyHash = u.hash160(pubKey);\n      for (const i of Script.decode(inputType.lastScript)) {\n        if (isBytes(i) && (equalBytes(i, pubKey) || equalBytes(i, pubKeyHash))) hasPubkey = true;\n      }\n      if (!hasPubkey) throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n      let hash;\n      if (inputType.txType === 'legacy') {\n        hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n      } else if (inputType.txType === 'segwit') {\n        let script = inputType.lastScript;\n        // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n        if (inputType.last.type === 'wpkh')\n          script = OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n        hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n      } else throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n      const sig = u.signECDSA(hash, privateKey, this.opts.lowR);\n      this.updateInput(\n        idx,\n        {\n          partialSig: [[pubKey, concatBytes(sig, new Uint8Array([sighash]))]],\n        },\n        true\n      );\n    }\n    return true;\n  }\n  // This is bad API. Will work if user creates and signs tx, but if\n  // there is some complex workflow with exchanging PSBT and signing them,\n  // then it is better to validate which output user signs. How could a better API look like?\n  // Example: user adds input, sends to another party, then signs received input (mixer etc),\n  // another user can add different input for same key and user will sign it.\n  // Even worse: another user can add bip32 derivation, and spend money from different address.\n  // Better api: signIdx\n  sign(privateKey: Signer, allowedSighash?: number[], _auxRand?: Bytes): number {\n    let num = 0;\n    for (let i = 0; i < this.inputs.length; i++) {\n      try {\n        if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;\n      } catch (e) {}\n    }\n    if (!num) throw new Error('No inputs signed');\n    return num;\n  }\n\n  finalizeIdx(idx: number): void {\n    this.checkInputIdx(idx);\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    const input = this.inputs[idx];\n    const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n    // Taproot finalize\n    if (inputType.txType === 'taproot') {\n      if (input.tapKeySig) input.finalScriptWitness = [input.tapKeySig];\n      else if (input.tapLeafScript && input.tapScriptSig) {\n        // Sort leafs by control block length.\n        const leafs = input.tapLeafScript.sort(\n          (a, b) =>\n            psbt.TaprootControlBlock.encode(a[0]).length -\n            psbt.TaprootControlBlock.encode(b[0]).length\n        );\n        for (const [cb, _script] of leafs) {\n          // Last byte is version\n          const script = _script.slice(0, -1);\n          const ver = _script[_script.length - 1];\n          const outScript = OutScript.decode(script);\n          const hash = tapLeafHash(script, ver);\n          const scriptSig = input.tapScriptSig.filter((i) => equalBytes(i[0].leafHash, hash));\n          let signatures: Bytes[] = [];\n          if (outScript.type === 'tr_ms') {\n            const m = outScript.m;\n            const pubkeys = outScript.pubkeys;\n            let added = 0;\n            for (const pub of pubkeys) {\n              const sigIdx = scriptSig.findIndex((i) => equalBytes(i[0].pubKey, pub));\n              // Should have exact amount of signatures (more -- will fail)\n              if (added === m || sigIdx === -1) {\n                signatures.push(P.EMPTY);\n                continue;\n              }\n              signatures.push(scriptSig[sigIdx][1]);\n              added++;\n            }\n            // Should be exact same as m\n            if (added !== m) continue;\n          } else if (outScript.type === 'tr_ns') {\n            for (const pub of outScript.pubkeys) {\n              const sigIdx = scriptSig.findIndex((i) => equalBytes(i[0].pubKey, pub));\n              if (sigIdx === -1) continue;\n              signatures.push(scriptSig[sigIdx][1]);\n            }\n            if (signatures.length !== outScript.pubkeys.length) continue;\n          } else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n            // Trying our best to sign what we can\n            const scriptDecoded = Script.decode(script);\n            signatures = scriptSig\n              .map(([{ pubKey }, signature]) => {\n                const pos = scriptDecoded.findIndex((i) => isBytes(i) && equalBytes(i, pubKey));\n                if (pos === -1)\n                  throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                return { signature, pos };\n              })\n              // Reverse order (because witness is stack and we take last element first from it)\n              .sort((a, b) => a.pos - b.pos)\n              .map((i) => i.signature);\n            if (!signatures.length) continue;\n          } else {\n            const custom = this.opts.customScripts;\n            if (custom) {\n              for (const c of custom) {\n                if (!c.finalizeTaproot) continue;\n                const scriptDecoded = Script.decode(script);\n                const csEncoded = c.encode(scriptDecoded);\n                if (csEncoded === undefined) continue;\n                const finalized = c.finalizeTaproot(script, csEncoded, scriptSig);\n                if (!finalized) continue;\n                input.finalScriptWitness = finalized.concat(psbt.TaprootControlBlock.encode(cb));\n                input.finalScriptSig = P.EMPTY;\n                cleanFinalInput(input);\n                return;\n              }\n            }\n            throw new Error('Finalize: Unknown tapLeafScript');\n          }\n          // Witness is stack, so last element will be used first\n          input.finalScriptWitness = signatures\n            .reverse()\n            .concat([script, psbt.TaprootControlBlock.encode(cb)]);\n          break;\n        }\n        if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');\n      } else throw new Error('finalize/taproot: unknown input');\n      input.finalScriptSig = P.EMPTY;\n      cleanFinalInput(input);\n      return;\n    }\n    if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');\n\n    let inputScript: Bytes = P.EMPTY;\n    let witness: Bytes[] = [];\n    // TODO: move input scripts closer to payments/output scripts\n    // Multisig\n    if (inputType.last.type === 'ms') {\n      const m = inputType.last.m;\n      const pubkeys = inputType.last.pubkeys;\n      let signatures = [];\n      // partial: [pubkey, sign]\n      for (const pub of pubkeys) {\n        const sign = input.partialSig.find((s) => equalBytes(pub, s[0]));\n        if (!sign) continue;\n        signatures.push(sign[1]);\n      }\n      signatures = signatures.slice(0, m);\n      if (signatures.length !== m) {\n        throw new Error(\n          `Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`\n        );\n      }\n      inputScript = Script.encode([0, ...signatures]);\n    } else if (inputType.last.type === 'pk') {\n      inputScript = Script.encode([input.partialSig[0][1]]);\n    } else if (inputType.last.type === 'pkh') {\n      inputScript = Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n    } else if (inputType.last.type === 'wpkh') {\n      inputScript = P.EMPTY;\n      witness = [input.partialSig[0][1], input.partialSig[0][0]];\n    } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n      throw new Error('Unknown inputs not allowed');\n\n    // Create final scripts (generic part)\n    let finalScriptSig: Bytes | undefined, finalScriptWitness: Bytes[] | undefined;\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        witness = Script.decode(inputScript).map((i) => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      witness = witness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') finalScriptWitness = witness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      finalScriptSig = Script.encode([Script.encode([0, u.sha256(inputType.lastScript)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      finalScriptSig = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {\n    } else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;\n\n    if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');\n    if (finalScriptSig) input.finalScriptSig = finalScriptSig;\n    if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;\n    cleanFinalInput(input);\n  }\n  finalize(): void {\n    for (let i = 0; i < this.inputs.length; i++) this.finalizeIdx(i);\n  }\n  extract(): Uint8Array {\n    if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');\n    if (!this.outputs.length) throw new Error('Transaction has no outputs');\n    if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');\n    return this.toBytes(true, true);\n  }\n  combine(other: Transaction): this {\n    for (const k of ['PSBTVersion', 'version', 'lockTime'] as const) {\n      if (this.opts[k] !== other.opts[k]) {\n        throw new Error(\n          `Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`\n        );\n      }\n    }\n    for (const k of ['inputs', 'outputs'] as const) {\n      if (this[k].length !== other[k].length) {\n        throw new Error(\n          `Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`\n        );\n      }\n    }\n    const thisUnsigned = this.global.unsignedTx ? RawOldTx.encode(this.global.unsignedTx) : P.EMPTY;\n    const otherUnsigned = other.global.unsignedTx\n      ? RawOldTx.encode(other.global.unsignedTx)\n      : P.EMPTY;\n    if (!equalBytes(thisUnsigned, otherUnsigned))\n      throw new Error(`Transaction/combine: different unsigned tx`);\n    this.global = psbt.mergeKeyMap(\n      psbt.PSBTGlobal,\n      this.global,\n      other.global,\n      undefined,\n      this.opts.allowUnknown\n    );\n    for (let i = 0; i < this.inputs.length; i++) this.updateInput(i, other.inputs[i], true);\n    for (let i = 0; i < this.outputs.length; i++) this.updateOutput(i, other.outputs[i], true);\n    return this;\n  }\n  clone(): Transaction {\n    // deepClone probably faster, but this enforces that encoding is valid\n    return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);\n  }\n}\n\nexport function PSBTCombine(psbts: Bytes[]): Bytes {\n  if (!psbts || !Array.isArray(psbts) || !psbts.length)\n    throw new Error('PSBTCombine: wrong PSBT list');\n  const tx = Transaction.fromPSBT(psbts[0]);\n  for (let i = 1; i < psbts.length; i++) tx.combine(Transaction.fromPSBT(psbts[i]));\n  return tx.toPSBT();\n}\n\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET: number = 0x80000000;\nexport function bip32Path(path: string): number[] {\n  const out: number[] = [];\n  if (!/^[mM]'?/.test(path)) throw new Error('Path must start with \"m\" or \"M\"');\n  if (/^[mM]'?$/.test(path)) return out;\n  const parts = path.replace(/^[mM]'?\\//, '').split('/');\n  for (const c of parts) {\n    const m = /^(\\d+)('?)$/.exec(c);\n    if (!m || m.length !== 3) throw new Error(`Invalid child index: ${c}`);\n    let idx = +m[1];\n    if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');\n    // hardened key\n    if (m[2] === \"'\") idx += HARDENED_OFFSET;\n    out.push(idx);\n  }\n  return out;\n}\n", "import { hex } from '@scure/base';\nimport * as P from 'micro-packed';\nimport { Address, type CustomScript, OutScript, checkScript, tapLeafHash } from './payment.ts';\nimport * as psbt from './psbt.ts';\nimport { CompactSizeLen, RawWitness, Script, VarBytes } from './script.ts';\nimport {\n  SignatureHash,\n  Transaction,\n  type TxOpts,\n  getInputType,\n  getPrevOut,\n  inputBeforeSign,\n  normalizeInput,\n  toVsize,\n} from './transaction.ts';\nimport {\n  type Bytes,\n  NETWORK,\n  PubT,\n  TAPROOT_UNSPENDABLE_KEY,\n  compareBytes,\n  equalBytes,\n  isBytes,\n  sha256,\n  validatePubkey,\n} from './utils.ts';\n\n// UTXO Select\nexport type Output = { address: string; amount: bigint } | { script: Uint8Array; amount: bigint };\nexport type Accumulated =\n  | {\n      indices: number[];\n      fee: bigint | undefined;\n      weight: number;\n      total: bigint;\n    }\n  | undefined;\ntype TapLeafScript = psbt.TransactionInput['tapLeafScript'];\ntype TB = Parameters<typeof psbt.TaprootControlBlock.encode>[0];\nconst encodeTapBlock = (item: TB) => psbt.TaprootControlBlock.encode(item);\n\nfunction iterLeafs(tapLeafScript: TapLeafScript, sigSize: number, customScripts?: CustomScript[]) {\n  if (!tapLeafScript || !tapLeafScript.length) throw new Error('no leafs');\n  const empty = () => new Uint8Array(sigSize);\n  // If user want to select specific leaf, which can signed,\n  // it is possible to remove all other leafs manually.\n  // Sort leafs by control block length.\n  const leafs = tapLeafScript.sort(\n    (a, b) => encodeTapBlock(a[0]).length - encodeTapBlock(b[0]).length\n  );\n  for (const [cb, _script] of leafs) {\n    // Last byte is version\n    const script = _script.slice(0, -1);\n    const ver = _script[_script.length - 1];\n    const outs = OutScript.decode(script);\n\n    let signatures: Bytes[] = [];\n    if (outs.type === 'tr_ms') {\n      const m = outs.m;\n      const n = outs.pubkeys.length - m;\n      for (let i = 0; i < m; i++) signatures.push(empty());\n      for (let i = 0; i < n; i++) signatures.push(P.EMPTY);\n    } else if (outs.type === 'tr_ns') {\n      for (const _pub of outs.pubkeys) signatures.push(empty());\n    } else {\n      if (!customScripts) throw new Error('Finalize: Unknown tapLeafScript');\n      const leafHash = tapLeafHash(script, ver);\n      for (const c of customScripts) {\n        if (!c.finalizeTaproot) continue;\n        const scriptDecoded = Script.decode(script);\n        const csEncoded = c.encode(scriptDecoded);\n        if (csEncoded === undefined) continue;\n        const pubKeys = scriptDecoded.filter((i) => {\n          if (!isBytes(i)) return false;\n          try {\n            validatePubkey(i, PubT.schnorr);\n            return true;\n          } catch (e) {\n            return false;\n          }\n        }) as Bytes[];\n        const finalized = c.finalizeTaproot(\n          script,\n          csEncoded,\n          pubKeys.map((pubKey) => [{ pubKey, leafHash }, empty()])\n        );\n        if (!finalized) continue;\n        return finalized.concat(encodeTapBlock(cb));\n      }\n    }\n    // Witness is stack, so last element will be used first\n    return signatures.reverse().concat([script, encodeTapBlock(cb)]);\n  }\n  throw new Error('there was no witness');\n}\n\nfunction estimateInput(\n  inputType: ReturnType<typeof getInputType>,\n  input: psbt.TransactionInput,\n  opts: TxOpts\n) {\n  let script: Bytes = P.EMPTY;\n  let witness: Bytes[] | undefined;\n\n  // schnorr sig is always 64 bytes. except for cases when sighash is not default!\n  if (inputType.txType === 'taproot') {\n    const SCHNORR_SIG_SIZE = inputType.sighash !== SignatureHash.DEFAULT ? 65 : 64;\n    if (input.tapInternalKey && !equalBytes(input.tapInternalKey, TAPROOT_UNSPENDABLE_KEY)) {\n      witness = [new Uint8Array(SCHNORR_SIG_SIZE)];\n    } else if (input.tapLeafScript) {\n      witness = iterLeafs(input.tapLeafScript, SCHNORR_SIG_SIZE, opts.customScripts);\n    } else throw new Error('estimateInput/taproot: unknown input');\n  } else {\n    // It is possible to grind signatures until it has minimal size (but changing fee value +N satoshi),\n    // which will make estimations exact. But will be very hard for multi sig (need to make sure all signatures has small size).\n    const empty = () => new Uint8Array(72); // max size of sigs\n    const emptyPub = () => new Uint8Array(33); // size of pubkey\n    let inputScript = P.EMPTY;\n    let inputWitness: Uint8Array[] = [];\n    const ltype = inputType.last.type;\n    if (ltype === 'ms') {\n      const m = inputType.last.m;\n      const sig: (number | Uint8Array)[] = [0];\n      for (let i = 0; i < m; i++) sig.push(empty());\n      inputScript = Script.encode(sig);\n    } else if (ltype === 'pk') {\n      // 71 sig + 1 sighash\n      inputScript = Script.encode([empty()]);\n    } else if (ltype === 'pkh') {\n      inputScript = Script.encode([empty(), emptyPub()]);\n    } else if (ltype === 'wpkh') {\n      inputScript = P.EMPTY;\n      inputWitness = [empty(), emptyPub()];\n    } else if (ltype === 'unknown' && !opts.allowUnknownInputs)\n      throw new Error('Unknown inputs are not allowed');\n    if (inputType.type.includes('wsh-')) {\n      // P2WSH\n      if (inputScript.length && inputType.lastScript.length) {\n        inputWitness = Script.decode(inputScript).map((i) => {\n          if (i === 0) return P.EMPTY;\n          if (isBytes(i)) return i;\n          throw new Error(`Wrong witness op=${i}`);\n        });\n      }\n      inputWitness = inputWitness.concat(inputType.lastScript);\n    }\n    if (inputType.txType === 'segwit') witness = inputWitness;\n    if (inputType.type.startsWith('sh-wsh-')) {\n      script = Script.encode([Script.encode([0, new Uint8Array(sha256.outputLen)])]);\n    } else if (inputType.type.startsWith('sh-')) {\n      script = Script.encode([...Script.decode(inputScript), inputType.lastScript]);\n    } else if (inputType.type.startsWith('wsh-')) {\n    } else if (inputType.txType !== 'segwit') script = inputScript;\n  }\n  let weight = 160 + 4 * VarBytes.encode(script).length;\n  let hasWitnesses = false;\n  if (witness) {\n    weight += RawWitness.encode(witness).length;\n    hasWitnesses = true;\n  }\n  return { weight, hasWitnesses };\n}\n\n// Exported for tests, internal method\nexport const _cmpBig = (a: bigint, b: bigint): 0 | 1 | -1 => {\n  const n = a - b;\n  if (n < 0n) return -1;\n  else if (n > 0n) return 1;\n  return 0;\n};\n\nexport type EstimatorOpts = TxOpts & {\n  // NOTE: fees less than 1 satoshi per vbyte is not supported. Please create issue if you have valid use case for that.\n  feePerByte: bigint; // satoshi per vbyte\n  changeAddress: string; // address where change will be sent\n  // Optional\n  alwaysChange?: boolean; // always create change, even if less than dust threshold\n  bip69?: boolean; // https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki\n  network?: typeof NETWORK;\n  dust?: number; // how much vbytes considered dust?\n  dustRelayFeeRate?: bigint; // fee per dust byte (DUST_RELAY_TX_FEE)\n  createTx?: boolean; // Create tx inside selection\n  requiredInputs?: psbt.TransactionInputUpdate[]; // these inputs always will be used\n  allowSameUtxo?: boolean; // allow using UTXO multiple times (for test purposes)\n};\n\nfunction getScript(o: Output, opts: TxOpts = {}, network = NETWORK) {\n  let script;\n  if ('script' in o && isBytes(o.script)) {\n    script = o.script;\n  }\n  if ('address' in o) {\n    if (typeof o.address !== 'string')\n      throw new Error(`Estimator: wrong output address=${o.address}`);\n    script = OutScript.encode(Address(network).decode(o.address));\n  }\n  if (!script) throw new Error('Estimator: wrong output script');\n  if (typeof o.amount !== 'bigint')\n    throw new Error(\n      `Estimator: wrong output amount=${\n        o.amount\n      }, should be of type bigint but got ${typeof o.amount}.`\n    );\n  if (script && !opts.allowUnknownOutputs && OutScript.decode(script).type === 'unknown') {\n    throw new Error(\n      'Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure'\n    );\n  }\n  if (!opts.disableScriptCheck) checkScript(script);\n  return script;\n}\n\n// exact is meaningless without additional accum (will often fail if not possible to find right utxo)\n// -> we support only exact+accum or accum\ntype SortStrategy = 'Newest' | 'Oldest' | 'Smallest' | 'Biggest';\ntype ExactStrategy = `exact${SortStrategy}`;\ntype AccumStrategy = `accum${SortStrategy}`;\n\nexport type SelectionStrategy =\n  | 'all'\n  | 'default'\n  | AccumStrategy\n  | `${ExactStrategy}/${AccumStrategy}`;\n\n// class, because we need to re-use normalized inputs, instead of parsing each time\n// internal stuff, exported for tests only\nexport class _Estimator {\n  private baseWeight: number;\n  private changeWeight: number;\n  private amount: bigint;\n  private requiredIndices: number[] = [];\n  private normalizedInputs: {\n    inputType: ReturnType<typeof getInputType>;\n    normalized: ReturnType<typeof normalizeInput>;\n    amount: bigint;\n    value: bigint;\n    estimate: { weight: number; hasWitnesses: boolean };\n  }[];\n  // Dust used in accumExact + change address algo\n  // - change address: can be smaller for segwit\n  // - accumExact: ???\n  private dust: bigint; // total dust limit (3||opts.dustRelayFeeRate * 182||opts.dust). Default: 546\n  private outputs: Output[];\n  private opts: EstimatorOpts;\n  constructor(inputs: psbt.TransactionInputUpdate[], outputs: Output[], opts: EstimatorOpts) {\n    this.outputs = outputs;\n    this.opts = opts;\n    if (typeof opts.feePerByte !== 'bigint')\n      throw new Error(\n        `Estimator: wrong feePerByte=${\n          opts.feePerByte\n        }, should be of type bigint but got ${typeof opts.feePerByte}.`\n      );\n    // Dust stuff\n    // TODO: think about this more:\n    // - current dust filters tx which cannot be relayed by core\n    // - but actual dust meaning is 'can be this amount spent?'\n    // - dust contains full tx size. but we can use other inputs to pay for outputDust (and parially inputsDust)?\n    // - not sure if we can spent anything with feePerByte: 3. It will be relayed, but will it be mined?\n    // - for now it works exactly as bitcoin-core. But will create change/outputs which cannot be spent (reasonable).\n    // Number of bytes needed to create and spend a UTXO.\n    // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.cpp#L28-L41\n    const inputsDust = 32 + 4 + 1 + 107 + 4; // NOTE: can be smaller for segwit tx?\n    const outputDust = 34; // NOTE: 'nSize = GetSerializeSize(txout)'\n    const dustBytes = opts.dust === undefined ? BigInt(inputsDust + outputDust) : opts.dust;\n    if (typeof dustBytes !== 'bigint') {\n      throw new Error(\n        `Estimator: wrong dust=${opts.dust}, should be of type bigint but got ${typeof opts.dust}.`\n      );\n    }\n    // 3 sat/vb is the default minimum fee rate used to calculate dust thresholds by bitcoin core.\n    // 3000 sat/kvb -> 3 sat/vb.\n    // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.h#L55\n    const dustFee = opts.dustRelayFeeRate === undefined ? 3n : opts.dustRelayFeeRate;\n    if (typeof dustFee !== 'bigint') {\n      throw new Error(\n        `Estimator: wrong dustRelayFeeRate=${opts.dustRelayFeeRate}, should be of type bigint but got ${typeof opts.dustRelayFeeRate}.`\n      );\n    }\n    // Dust uses feePerbyte by default, but we allow separate dust fee if needed\n    this.dust = dustBytes * dustFee;\n    if (opts.requiredInputs !== undefined && !Array.isArray(opts.requiredInputs))\n      throw new Error(`Estimator: wrong required inputs=${opts.requiredInputs}`);\n    const network = opts.network || NETWORK;\n    let amount = 0n;\n    // Base weight: tx with outputs, no inputs\n    let baseWeight = 32;\n    for (const o of outputs) {\n      const script = getScript(o, opts, opts.network);\n      baseWeight += 32 + 4 * VarBytes.encode(script).length;\n      amount += o.amount;\n    }\n    if (typeof opts.changeAddress !== 'string')\n      throw new Error(`Estimator: wrong change address=${opts.changeAddress}`);\n    let changeWeight =\n      baseWeight +\n      32 +\n      4 * VarBytes.encode(OutScript.encode(Address(network).decode(opts.changeAddress))).length;\n    baseWeight += 4 * CompactSizeLen.encode(outputs.length).length;\n    // If there a lot of outputs change can change fee\n    changeWeight += 4 * CompactSizeLen.encode(outputs.length + 1).length;\n    this.baseWeight = baseWeight;\n    this.changeWeight = changeWeight;\n    this.amount = amount;\n    const allInputs = Array.from(inputs);\n    if (opts.requiredInputs) {\n      for (let i = 0; i < opts.requiredInputs.length; i++)\n        this.requiredIndices.push(allInputs.push(opts.requiredInputs[i]) - 1);\n    }\n    const inputKeys = new Set();\n    this.normalizedInputs = allInputs.map((i) => {\n      const normalized = normalizeInput(\n        i,\n        undefined,\n        undefined,\n        opts.disableScriptCheck,\n        opts.allowUnknown\n      );\n      inputBeforeSign(normalized); // check fields\n      const key = `${hex.encode(normalized.txid!)}:${normalized.index}`;\n      if (!opts.allowSameUtxo && inputKeys.has(key))\n        throw new Error(`Estimator: same input passed multiple times: ${key}`);\n      inputKeys.add(key);\n      const inputType = getInputType(normalized, opts.allowLegacyWitnessUtxo);\n      const prev = getPrevOut(normalized);\n      const estimate = estimateInput(inputType, normalized, this.opts);\n      const value = prev.amount - opts.feePerByte * BigInt(toVsize(estimate.weight)); // value = amount-fee\n      return { inputType, normalized, amount: prev.amount, value, estimate };\n    });\n  }\n  private checkInputIdx(idx: number) {\n    if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.normalizedInputs.length)\n      throw new Error(`Wrong input index=${idx}`);\n    return idx;\n  }\n  private sortIndices(indices: number[]) {\n    return indices.slice().sort((a, b) => {\n      const ai = this.normalizedInputs[this.checkInputIdx(a)];\n      const bi = this.normalizedInputs[this.checkInputIdx(b)];\n      const out = compareBytes(ai.normalized.txid!, bi.normalized.txid!);\n      if (out !== 0) return out;\n      return ai.normalized.index! - bi.normalized.index!;\n    });\n  }\n  private sortOutputs(outputs: Output[]) {\n    const scripts = outputs.map((o) => getScript(o, this.opts, this.opts.network));\n    const indices = outputs.map((_, j) => j);\n    return indices.sort((a, b) => {\n      const aa = outputs[a].amount;\n      const ba = outputs[b].amount;\n      const out = _cmpBig(aa, ba);\n      if (out !== 0) return out;\n      return compareBytes(scripts[a], scripts[b]);\n    });\n  }\n  private getSatoshi(weigth: number) {\n    return this.opts.feePerByte * BigInt(toVsize(weigth));\n  }\n\n  // Sort by value instead of amount\n  get biggest(): number[] {\n    return this.normalizedInputs\n      .map((_i, j) => j)\n      .sort((a, b) => _cmpBig(this.normalizedInputs[b].value, this.normalizedInputs[a].value));\n  }\n  get smallest(): number[] {\n    return this.biggest.reverse();\n  }\n  // These assume that UTXO array has historical order.\n  // Otherwise, we have no way to know which tx is oldest\n  // Explorers usually give UTXO in this order.\n  get oldest(): number[] {\n    return this.normalizedInputs.map((_i, j) => j);\n  }\n  get newest(): number[] {\n    return this.oldest.reverse();\n  }\n  // exact - like blackjack from coinselect.\n  // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.\n  // If not, it will accumulate largest utxo until value is close to targetValue+dust.\n  accumulate(indices: number[], exact = false, skipNegative = true, all = false): Accumulated {\n    // TODO: how to handle change addresses?\n    // - cost of input\n    // - cost of change output (if input requires change)\n    // - cost of output spending\n    // Dust threshold should be significantly bigger, no point in\n    // creating an output, which cannot be spent.\n    // coinselect doesn't consider cost of output address for dust.\n    // Changing that can actually reduce privacy\n    let weight = this.opts.alwaysChange ? this.changeWeight : this.baseWeight;\n    let hasWitnesses = false;\n    let num = 0;\n    let inputsAmount = 0n;\n    const targetAmount = this.amount;\n    const res: Set<number> = new Set();\n    let fee;\n    for (const idx of this.requiredIndices) {\n      this.checkInputIdx(idx);\n      if (res.has(idx)) throw new Error('required input encountered multiple times'); // should not happen\n      const { estimate, amount } = this.normalizedInputs[idx];\n      let newWeight = weight + estimate.weight;\n      if (!hasWitnesses && estimate.hasWitnesses) newWeight += 2; // enable witness if needed\n      const totalWeight = newWeight + 4 * CompactSizeLen.encode(num).length; // number of outputs can change weight\n      fee = this.getSatoshi(totalWeight);\n      weight = newWeight;\n      if (estimate.hasWitnesses) hasWitnesses = true;\n      num++;\n      inputsAmount += amount;\n      res.add(idx);\n      // inputsAmount is enough to cover cost of tx\n      if (!all && targetAmount + fee <= inputsAmount && num >= this.requiredIndices.length)\n        return { indices: Array.from(res), fee, weight: totalWeight, total: inputsAmount };\n    }\n    for (const idx of indices) {\n      this.checkInputIdx(idx);\n      if (res.has(idx)) continue; // skip required inputs\n      const { estimate, amount, value } = this.normalizedInputs[idx];\n      let newWeight = weight + estimate.weight;\n      if (!hasWitnesses && estimate.hasWitnesses) newWeight += 2; // enable witness if needed\n      const totalWeight = newWeight + 4 * CompactSizeLen.encode(num).length; // number of outputs can change weight\n      fee = this.getSatoshi(totalWeight);\n      // Best case scenario exact(biggest) -> we find biggest output, less than target+threshold\n      if (exact && amount + inputsAmount > targetAmount + fee + this.dust) continue; // skip if added value is bigger than dust\n      // Negative: cost of using input is more than value provided (negative)\n      // By default 'blackjack' mode in coinselect doesn't use that, which means\n      // it will use negative output if sorted by 'smallest'\n      if (skipNegative && value <= 0n) continue;\n      weight = newWeight;\n      if (estimate.hasWitnesses) hasWitnesses = true;\n      num++;\n      inputsAmount += amount;\n      res.add(idx);\n      // inputsAmount is enough to cover cost of tx\n      if (!all && targetAmount + fee <= inputsAmount)\n        return { indices: Array.from(res), fee, weight: totalWeight, total: inputsAmount };\n    }\n    if (all) {\n      const newWeight = weight + 4 * CompactSizeLen.encode(num).length;\n      return { indices: Array.from(res), fee, weight: newWeight, total: inputsAmount };\n    }\n    return undefined;\n  }\n\n  // Works like coinselect default method\n  default(): Accumulated {\n    const { biggest } = this;\n    const exact = this.accumulate(biggest, true, false);\n    if (exact) return exact;\n    return this.accumulate(biggest);\n  }\n\n  private select(strategy: SelectionStrategy) {\n    if (strategy === 'all') {\n      return this.accumulate(\n        this.normalizedInputs.map((_, j) => j),\n        false,\n        true,\n        true\n      );\n    }\n    if (strategy === 'default') return this.default();\n    const data: Record<SortStrategy, () => number[]> = {\n      Oldest: () => this.oldest,\n      Newest: () => this.newest,\n      Smallest: () => this.smallest,\n      Biggest: () => this.biggest,\n    };\n    if (strategy.startsWith('exact')) {\n      const [exactData, left] = strategy.slice(5).split('/') as [SortStrategy, SelectionStrategy];\n      if (!data[exactData]) throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n      strategy = left;\n      const exact = this.accumulate(data[exactData](), true, true);\n      if (exact) return exact;\n    }\n    if (strategy.startsWith('accum')) {\n      const accumData = strategy.slice(5) as SortStrategy;\n      if (!data[accumData]) throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n      return this.accumulate(data[accumData]());\n    }\n    throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n  }\n\n  result(strategy: SelectionStrategy) {\n    const s = this.select(strategy);\n    if (!s) return;\n    const { indices, weight, total } = s;\n    let needChange = this.opts.alwaysChange;\n    const changeWeight = this.opts.alwaysChange\n      ? weight\n      : weight + (this.changeWeight - this.baseWeight);\n\n    const changeFee = this.getSatoshi(changeWeight);\n    let fee = s.fee;\n    const change = total - this.amount - changeFee;\n    if (change > this.dust) needChange = true;\n    let inputs = indices;\n    let outputs = Array.from(this.outputs);\n    if (needChange) {\n      fee = changeFee;\n      // this shouldn't happen!\n      if (change < 0n) throw new Error(`Estimator.result: negative change=${change}`);\n      outputs.push({ address: this.opts.changeAddress, amount: change });\n    }\n    if (this.opts.bip69) {\n      inputs = this.sortIndices(inputs);\n      outputs = this.sortOutputs(outputs).map((i) => outputs[i]);\n    }\n    const res = {\n      inputs: inputs.map((i) => this.normalizedInputs[i].normalized),\n      outputs,\n      fee,\n      weight: this.opts.alwaysChange ? s.weight : changeWeight,\n      change: !!needChange,\n    };\n    let tx;\n    if (this.opts.createTx) {\n      const { inputs, outputs } = res;\n      tx = new Transaction(this.opts);\n      for (const i of inputs) tx.addInput(i);\n      for (const o of outputs)\n        tx.addOutput({ ...o, script: getScript(o, this.opts, this.opts.network) });\n    }\n    return Object.assign(res, { tx });\n    // return { ...res, tx: tx };\n  }\n}\n\nexport function selectUTXO(\n  inputs: psbt.TransactionInputUpdate[],\n  outputs: Output[],\n  strategy: SelectionStrategy,\n  opts: EstimatorOpts\n) {\n  // Defaults: do we want bip69 by default?\n  const _opts = { createTx: true, bip69: true, ...opts };\n  const est = new _Estimator(inputs, outputs, _opts);\n  return est.result(strategy);\n}\n", "/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  compareBytes,\n  concatBytes,\n  isBytes,\n  pubSchnorr,\n  randomPrivateKeyBytes,\n  taprootTweakPubkey,\n} from './utils.ts';\n// should multisig be exported as classicMultisig?\n// prettier-ignore\nexport {\n  multisig,\n  p2ms, p2pk, p2pkh, p2sh, p2tr, p2tr_ms, p2tr_ns, p2tr_pk, p2wpkh, p2wsh\n} from './payment.ts';\nexport {\n  CompactSize,\n  MAX_SCRIPT_BYTE_LENGTH,\n  OP,\n  RawTx,\n  RawWitness,\n  Script,\n  ScriptNum,\n} from './script.ts';\nexport type { ScriptType } from './script.ts';\nexport { getInputType, Transaction } from './transaction.ts';\nexport { NETWORK, TAPROOT_UNSPENDABLE_KEY, TEST_NETWORK } from './utils.ts';\nexport { selectUTXO } from './utxo.ts';\n\nexport const utils = {\n  isBytes,\n  concatBytes,\n  compareBytes,\n  pubSchnorr,\n  randomPrivateKeyBytes,\n  taprootTweakPubkey,\n};\n\nexport {\n  _sortPubkeys,\n  Address,\n  combinations,\n  getAddress,\n  OutScript,\n  sortedMultisig,\n  taprootListToTree,\n  WIF,\n} from './payment.ts'; // remove\n// remove\nexport type { CustomScript, OptScript } from './payment.ts';\nexport { _DebugPSBT, TaprootControlBlock } from './psbt.ts'; // remove\nexport { bip32Path, Decimal, DEFAULT_SEQUENCE, PSBTCombine, SigHash } from './transaction.ts'; // remove\nexport { _cmpBig, _Estimator } from './utxo.ts';\n"],
  "mappings": "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",
  "names": ["i", "view", "prefix", "def", "isBytes", "concatBytes", "equalBytes", "concatBytes", "PubT", "isBytes", "OP", "isBytes", "flag", "value", "val", "k", "equalBytes", "isBytes", "equalBytes", "a", "b", "concatBytes", "i", "prefix", "data", "def", "isBytes", "SignatureHash", "SigHash", "equalBytes", "concatBytes", "isBytes", "equalBytes", "inputs", "outputs", "utils", "isBytes", "concatBytes"]
}
